<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS独立开发者使用Bmob第三方后台服务之用户管理]]></title>
    <url>%2F1636968213.html</url>
    <content type="text"><![CDATA[一、属性BmobUser除了从BmobObject继承的属性外，还有几个特定的属性： username: 用户的用户名（必需）。 password: 用户的密码（必需）。 email: 用户的电子邮件地址（可选）。 BmobUser自动处理用户账户管理所需的功能。 12345-(void)setUsername:(NSString *)username;//用户名，必需-(void)setPassword:(NSString*)password;//密码，必需-(void)setEmail:(NSString *)email;//设置邮箱-(void)setObject:(id)obj forKey:(id)key;//设置某个属性的值-(id)objectForKey:(id)key;//得到某个属性的值 二、注册应用很常见的一个功能就是，注册用户，使用BmobUser注册用户也不复杂，如下的例子所示：1234567891011121314BmobUser *bUser = [[BmobUser alloc] init]; [bUser setUsername:self.nameTextField.text]; [bUser setPassword:self.passwordTextField.text]; [bUser signUpInBackgroundWithBlock:^ (BOOL isSuccessful, NSError *error)&#123; if (isSuccessful)&#123; NSLog(@&quot;Sign up successfully&quot;); NSString *result = [NSString stringWithFormat:@&quot;注册成功\n用户名:%@\n密码:%@\n去试试登录吧&quot;,self.nameTextField.text,self.passwordTextField.text]; [self showResultInfo:result]; &#125; else &#123; NSLog(@&quot;%@&quot;,error); [self showResultInfo:@&quot;注册失败，查看控制台信息&quot;]; &#125; &#125;]; 注意点： 有些时候你可能需要在用户注册时发送一封邮件，以确认用户邮箱的真实性。这时，你只需要登录自己的应用管理后台，在应用设置-&gt;邮件设置（下图）中把“邮箱验证”功能打开，Bmob云后端就会在用户注册时自动发动一封验证给用户。 username字段是大小写敏感的字段，如果你希望应用的用户名不区分大小写，请在注册和登录时进行大小写的统一转换。 三、登录当用户注册成功后，需要让他们以后能够登录到他们的账户使用应用。要做到这点可以使用方法一 12[BmobUser loginWithUsernameInBackground:self.nameTextField.text password:self.passwordTextField.text]; 方法二 123456789[BmobUser loginWithUsernameInBackground:self.nameTextField.text password:self.passwordTextField.text block:^(BmobUser *user, NSError *error) &#123; if (user) &#123; NSString *result = [NSString stringWithFormat:@&quot;登录成功\n用户名:%@\n密码:%@\n去试试获取当前用户吧&quot;,user.username,user.password]; [self showResultInfo:result]; &#125;else&#123; NSLog(@&quot;%@&quot;,error); [self showResultInfo:@&quot;登录失败，查看可控制台消息&quot;]; &#125;&#125;]; 可以看到Bmob里面提供了很多的方法，根据需要调用 四、获取当前用户每次你登录成功，都会在本地磁盘中有一个缓存的用户对象作为当前用户，可以获取这个缓存的用户对象来进行登录：123456789BmobUser *user = [BmobUser currentUser]; if (user) &#123; //进行操作 NSString *result = [NSString stringWithFormat:@&quot;登录成功\n用户名:%@\n密码:%@\n去试试更新用户吧&quot;,user.username,user.password]; [self showResultInfo:result]; &#125;else&#123; //对象为空时，可打开用户注册界面 [self showResultInfo:@&quot;当前没有用户&quot;]; &#125; 当然，你也可以用如下的方法清除缓存用户对象：1[BmobUser logout]; 五、更新用户当用户登录成功后，在本地有个缓存的用户对象，如果开发者希望更改当前用户的某个属性可按如下代码操作:123456789101112131415BmobUser *bUser = [BmobUser currentUser]; if (bUser) &#123; [bUser setObject:self.nameTextField.text forKey:@&quot;username&quot;]; [bUser updateInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) &#123; if (isSuccessful) &#123; [self showResultInfo:@&quot;更新用户成功，去查看当前用户信息吧&quot;]; &#125;else&#123; NSLog(@&quot;error %@&quot;,[error description]); [self showResultInfo:@&quot;更新用户失败，控制台查看信息&quot;]; &#125; &#125;]; &#125;else&#123; [self showResultInfo:@&quot;当前未登录&quot;]; &#125; 一般来说，使用当前用户对象来进行资料更新可能会遇到一个问题。如果当前用户上次登录的时间距离当前时间过长，存放在本地的Token就有可能会过期，导致用户更新资料失败，这是需要重新登录，登录成功后才能更新资料。 在更新用户信息时，如果用户邮箱有变更并且在管理后台打开了邮箱验证选项的话，Bmob云后端同样会自动发动一封邮件验证信息给用户。 六、查询用户查询用户和查询普通对象一样，只需指定BmobUser类即可，如下：- C1234567891011121314151617181920212223BmobQuery *query = [BmobUser query]; [query whereKey:@&quot;username&quot; equalTo:self.nameTextField.text]; [query findObjectsInBackgroundWithBlock:^(NSArray *array, NSError *error) &#123; if (error) &#123; NSLog(@&quot;%@&quot;,error); [self showResultInfo:@&quot;查询出错，查看控制台信息&quot;]; &#125;else&#123; if (array.count&gt;0) &#123; for (BmobUser *user in array) &#123; // demo中只有一个用户，所以把显示结果的放在循环内了 NSLog(@&quot;objectid %@&quot;,user.objectId); NSString *result = [NSString stringWithFormat:@&quot;查询成功\n用户名:%@\n用户id:%@&quot;,user.username,user.objectId]; [self showResultInfo:result]; &#125; &#125;else&#123; [self showResultInfo:@&quot;没有查询到结果，请修改信息后查询&quot;]; &#125; &#125; &#125;]; 在Bmob后台查看用户表 七、修改密码使用旧密码来重置新密码的接口，示例如下：修改12345678910BmobUser *user = [BmobUser currentUser]; [user updateCurrentUserPasswordWithOldPassword:self.nameTextField.text newPassword:self.passwordTextField.text block:^(BOOL isSuccessful, NSError *error) &#123; if (isSuccessful) &#123; [self showResultWithLoginInfo:user.username]; &#125; else &#123; NSLog(@&quot;change password error:%@&quot;,error); [self showResultInfo:@&quot;修改失败，查看可控制台消息&quot;]; &#125; &#125;]; 修改成功之后登录1234567891011121314//用新密码登录 [BmobUser loginInbackgroundWithAccount:result andPassword:self.passwordTextField.text block:^(BmobUser *user, NSError *error) &#123; if (error) &#123; NSLog(@&quot;login error:%@&quot;,error); [self showResultInfo:@&quot;登录失败，查看可控制台消息&quot;]; &#125; else &#123; NSLog(@&quot;user:%@&quot;,user); NSString *result = [NSString stringWithFormat:@&quot;登录成功\n用户名:%@\n用户ID:%@\n&quot;,user.username,user.objectId]; [self showResultInfo:result]; &#125; &#125;]; 八、邮箱找回(修改)密码 前提是在注册操作的时候有添加过邮箱 一旦你引入了一个密码系统，那么肯定会有用户忘记密码的情况。对于这种情况，我们提供了一种方法，让用户安全地重置起密码。 重置密码的流程很简单，开发者只需要求用户输入注册的电子邮件地址即可123456789[BmobUser requestPasswordResetInBackgroundWithEmail:self.nameTextField.text block:^(BOOL isSuccessful, NSError *error) &#123; if (isSuccessful) &#123; [self showResultInfo:@&quot;发送成功，请去邮箱内查看邮件&quot;]; &#125;else&#123; NSLog(@&quot;%@&quot;,error); [self showResultInfo:@&quot;发送失败，请查看控制台信息&quot;]; &#125; &#125;]; 以下为未开启邮箱验证和注册时未绑定邮箱的 密码重置流程如下： 用户输入他们的电子邮件，请求重置自己的密码。 Bmob向他们的邮箱发送一封包含特殊的密码重置连接的电子邮件。 用户根据向导点击重置密码连接，打开一个特殊的Bmob页面，根据提示，他们可以输入一个新的密码。 用户的密码已被重置为新输入的密码。 九、总结注意点： 需要在Bmob后台开启邮箱认证 Bmob后台User表里可添加字段来完善用户信息 通过邮箱操作密码等信息的需要在注册是要求用户验证邮箱，否则操作失败 Bmob接入具体操作可查看上一篇文章iOS独立开发者使用Bmob第三方后台服务初探本文同步至个人博客代码传送门，欢迎star,感兴趣的可以留言一起探讨。搜索公众号JacerooChu或扫描下方二维码一起讨论和获取更多信息。iOS独立开发者使用Bmob第三方后台服务之用户管理]]></content>
      <tags>
        <tag>Bmob</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS独立开发者使用Bmob第三方后台服务初探]]></title>
    <url>%2F1318804238.html</url>
    <content type="text"><![CDATA[Bmob后端云提供可视化的云端数据表设计界面，轻松建库建表。支持10种不同数据类型存储：如字符串，整型，数组等。 一、介绍Bmob后端云提供可视化的云端数据表设计界面，轻松建库建表。支持10种不同数据类型存储：如字符串，整型，数组等。 声明不是为此服务打广告，只是介绍使用 二、简单使用 注册Bmob帐号在网址栏输入www.bmob.cn或者在百度输入Bmob进行搜索，打开Bmob官网后，点击右上角的“注册”，在跳转页面填入你的姓名、邮箱、设置密码，确认后到你的邮箱激活Bmob账户，你就可以用Bmob轻松开发应用了。 网站后台创建应用登录账号进入bmob后台后，点击后台界面左上角“创建应用”，在弹出框输入你应用的名称，然后确认，你就拥有了一个等待开发的应用。 获取应用密钥和下载SDK选择你要开发的应用，进入该应用 在跳转页面，进入设置/应用密钥，点击复制，即可得到Application ID 获取Application ID后，下载SDK，开发者可以根据自己的需求选择相应的iOS SDK 或Android SDK，点击下载即可。 三、iOS端集成SDK方式 直接下载SDK导入到项目中 将BmobSDK引入项目:在你的XCode项目工程中，添加BmobSDK.framework 添加使用的系统framework: 在你的XCode工程中Project -&gt;TARGETS -&gt; Build Phases-&gt;Link Binary With Libraries引入CoreLocation.framework、Security.framework、CoreGraphics.framework、MobileCoreServices.framework、CFNetwork.framework、CoreTelephony.framework、SystemConfiguration.framework、libz.1.2.5.tbd、libicucore.tbd、libsqlite3.tbd、libc++.tbd、photos.framework 通过Pods导入，在Podfile中写入1234platform :ios,&apos;9.0&apos;target &apos;BmopDataDemo&apos; dopod &apos;BmobSDK&apos;end 之后执行Pod install命令进行安装 四、iOS简单使用 设置应用的BmobKey在你的XCode工程中的AppDelegate.m文件中创建应用Key，填入申请的授权Key（SDK使用的是应用密钥里的Application ID），示例如下： 需要在Bmob控制台先创建表，然后才可进行查删改增的操作 1234-(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [Bmob registerWithAppKey:@&quot;申请的Application ID&quot;]; return YES;&#125; 添加一条数据 12345678910111213BmobObject *gameScore = [BmobObject objectWithClassName:@&quot;Customer&quot;]; [gameScore setObject:@&quot;小明&quot; forKey:@&quot;UserName&quot;]; [gameScore setObject:@&quot;1993-07-22&quot; forKey:@&quot;UserBirthDay&quot;]; [gameScore setObject:@YES forKey:@&quot;Sex&quot;]; [gameScore saveInBackgroundWithResultBlock:^(BOOL isSuccessful, NSError *error) &#123; //进行操作 if (isSuccessful) &#123; self.userId = gameScore.objectId; self.showInfo.text =@&quot;添加成功&quot;; &#125;else&#123; self.showInfo.text =@&quot;添加失败&quot;; &#125; &#125;]; 查询一条数据 - C12345678910111213141516 BmobQuery *bquery = [BmobQuery queryWithClassName:@&quot;Customer&quot;];//查找GameScore表里面id为0c6db13c的数据[bquery getObjectInBackgroundWithId:self.userId block:^(BmobObject *object,NSError *error)&#123; if (error)&#123; //进行错误处理 &#125;else&#123; //表里有id为0c6db13c的数据 if (object) &#123; //得到playerName和cheatMode NSString *playerName = [object objectForKey:@&quot;UserName&quot;]; BOOL cheatMode = [[object objectForKey:@&quot;cheatMode&quot;] boolValue]; NSLog(@&quot;%@----%i&quot;,playerName,cheatMode); self.showInfo.text =playerName; &#125; &#125;&#125;]; 删除一条数据 12345678910111213 BmobQuery *bquery = [BmobQuery queryWithClassName:@&quot;Customer&quot;];[bquery getObjectInBackgroundWithId:self.userId block:^(BmobObject *object, NSError *error)&#123; if (error) &#123; //进行错误处理 &#125; else&#123; if (object) &#123; //异步删除object [object deleteInBackground]; self.showInfo.text =@&quot;删除成功&quot;; &#125; &#125;&#125;]; Bmob控制台 其他操作请参考官方文档。代码上传至GittHub,欢迎star更多文章关注公众号JackerooChu获取更多文章资源。]]></content>
      <tags>
        <tag>Bmob</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Office 2019 Mac 破解版分享]]></title>
    <url>%2F3716873143.html</url>
    <content type="text"><![CDATA[一、应用介绍&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 全新的、富有时代气息的 Word、Excel、PowerPoint、Outlook 和 OneNote — 将熟悉的 Office 与你钟爱的独有 Mac 功能相结合，让你可以快速上手。无论身处何处，你都能随时创建精美的文档，深入获取各类信息，从容自信地展示。 Office 应用程序功能强大，借助 Office 应用程序，你可以在平板电脑、手机和 Web 上随时完成工作。内置工具能更好地支持团队协作，团队成员可以共享、审阅和共同编辑文档、演示文稿和笔记，让你的团队更高效紧密合作。 二、安装步骤 打开 Office20191618.zip 文件夹，获得以下文件： 双击运行Setup.pkg 文件进入安装操作 这里可以选择安装位置以及自定义安装，把不需要的office功能去掉 打开任意office软件，此处以Word为例 任意选择，影响不大 三、激活方法 运行在第一步中获取的文件Microsoft_Office_2019_VL_Serializer.pkg 如果出现这种情况，请在安全设置中打开任何来源 如果没有任何来源选项，请在终端输入 sudo spctl --master-disable 会要求输入电脑密码，此处输入不显示，确保输入正确后回车即可 激活文件安装 打开软件测试 至此，Mac版的Office 2019就安装完成了。 四、资源获取由于某盘会和谐文件，如有需要请搜索公众号JackerooChu或者扫描二维码私信或者在公众号对应文章下评论留下邮箱，稍后会一一发送文件或者临时下载地址。 ps: 仅供学习研究使用，不存在任何商业利益行为，请支持正版]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于苹果内购那点破事儿（3.1.1大礼包解决方案）]]></title>
    <url>%2F2007592920.html</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家都知道想要在AppStore上线带有虚拟物品交易的app必须要走苹果的内购渠道，否则就会因为3.1.1条款被拒绝，如图所示： 前言大家都知道想要在AppStore上线带有虚拟物品交易的app必须要走苹果的内购渠道，否则就会因为3.1.1条款被拒绝，如图所示： 翻译之后的意思是：指南3.1.1商业支付-应用程序购买 我们注意到，您的应用程序或其元数据可以通过应用程序内购买API之外的其他方式购买应用程序中的内容、服务或功能，这不适合于App Store。 下一步 虽然您所包括的支付系统可以在应用程序外部进行交易，但如果可购买的内容、功能或服务打算在应用程序中使用，则必须在应用程序中使用应用程序内购买来购买，除非是指南中提到的类型。3.1.3的App Store审查指南。 虚拟物品包括会员、报名费、视频购买等等非实物交易 最近上线一个包含活动报名以及视频付费播放的app，因为有虚拟物品交易和实物交易，在项目中集成了微信支付和支付宝支付，一开始采取的是这两种方式来进行支付，测试完毕提交审核，第二天一早便收到苹果拒绝的回复： 拒绝的原因有两个： 包含有测试数据 有虚拟物品交易没有使用内购 第一条被拒的原因是因为后台没有变更数据库，导致显示的数据带有测试字样，直接被苹果拒绝并截图返回 在此也是提醒各位在提交审核的时候避免出现测试、Test、Beat、Demo、Trial等字样，苹果审核那边看到如此字样直接拒绝。 解决方案不需要重新打包上传，在和后台沟通后修改掉以上会被拒绝的字眼后直接回复苹果邮件： 然后等待苹果审核，然而还是没有避免掉3.1.1的条款，多次回复邮件说明情况还是被拒绝，后来和后台商量将所有活动报名和视频播放都改为免费，不需收费便可直接使用，回复邮件并附属上说明图片（回复的时候可以直接添加附件即可） 这一次的提交之后，苹果审核那边时间相对延长了一天，之前都是隔天就给了回馈，然而收到的还是3.1.1条款拒绝，截图返回如下： 看到图片的时候想到可能是因为显示了票价，此时很崩溃有没有？？？既然回复邮件说明都不奏效，那只能另寻出路了。。。 终极解决方案 和后台商量添加审核字段isCheck来标识是否在审核期间（如下图） app端对服务器返回的字段进行重新布局，在列表页面对价格进行隐藏，详情页将价格cell进行隐藏，结果如下图 在app端显示如下： 至此，重新打包上传，过了一晚边收到审核通过的消息，在发布应用后便可让后台改回原来的价格，app正常使用了。 总结 苹果审核比较严格，对测试数据把控需严谨。 此处给的方案治标不治本，业务需要的话还是需要走苹果提供的内购渠道。 以此方法上线的app在后期有几率被苹果复审下架。 版本迭代的时候需要再次跟后台沟通改变isCheck的值 ios小白一枚，请多多关照，不喜勿喷]]></content>
      <tags>
        <tag>iOS，苹果审核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[升级macOs Mojave之后CleanMyMac X破解版，有需要自取]]></title>
    <url>%2F24798.html</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CleanMyMac 4是一款功能强大的Mac系统优化清理工具，使用旨在帮助用户更加方便的清理您系统中的所有垃圾，从而加快电脑运行速度，保持最佳性能，更加稳定、流畅、快速，使用CleanMyMac4，您可自动清理各种11种不同类型的垃圾文件、浏览器缓存、日志记录、清理iPhoto垃圾、垃圾邮件、卸载软件以及删除清理各种扩展等，电脑从此更加干净清爽，支持自动定时清理，非常的方便！ 更多文章请访问个人博客 此出文件仅供学习研究使用，其他商业行为请下载官方正版 扫描上方二维码或直接搜索JackerooChu关注公众号获取资源。 微信扫描上方二维码或直接搜索速查天气，体验小程序。]]></content>
  </entry>
  <entry>
    <title><![CDATA[图像处理库GPUImage简单使用]]></title>
    <url>%2F47905.html</url>
    <content type="text"><![CDATA[一、介绍&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPUImage是一个基于OpenGL ES 2.0的开源的图像处理库，作者是Brad Larson。GPUImage将OpenGL ES封装为简洁的Objective-C或Swift接口，可以用来给图像、实时相机视频、电影等添加滤镜。 二、使用1.导入GPUImage两种方式a.使用 cocopods导入1234platform :ios, &apos;9.0&apos;target &apos;GPUImageDemo&apos; dopod &apos;GPUImage&apos;end 注：给项目添加cocopods等操作在此不做多余赘述 b.手动导入 （1）.首先下载GPUImage，下载地址 （2）.解压后，在framework 目录下，打开GPUImage.xcodeproj工程（3）.因为 GPUImage是一个开源的库 ，所以需要自己生成 静态库（以前的笨方法把整个工程加入项目，这在使用中出现了很不不必要的麻烦）（4）.运行该工程（生成 用于真机和模拟器的lib) （5）.点击Products下的 libGPUImage.a，右键， show in finder 将 两个lib 合并（方法，详见关于 创建静态库的博文） （6）.将 GPUImage.h文件中包含的头文件全部 提取到 header文件中 2.使用（1）.导入头文件12#import &lt;GPUImageView.h&gt;#import &lt;GPUImage/GPUImage.h&gt; （2）.使用滤镜12345678910111213141516171819UIImage *inputImage =[UIImage imageNamed:@&quot;lzl&quot;];// 创建滤镜GPUImageVignetteFilter *disFilter = [[GPUImageVignetteFilter alloc] init];//设置要渲染的区域[self.filter forceProcessingAtSize:inputImage.size];[self.filter useNextFrameForImageCapture];//获取数据源GPUImagePicture *stillImageSource = [[GPUImagePicture alloc]initWithImage:inputImage];//添加上滤镜[stillImageSource addTarget:self.filter];//开始渲染[stillImageSource processImage];//获取渲染后的图片UIImage *newImage = [self.filter imageFromCurrentFramebuffer];//加载出来UIImageView *imageView = [[UIImageView alloc] initWithImage:newImage];imageView.frame = CGRectMake(50,0,250 ,250);[self.view addSubview:imageView]; （3）.效果 三、概念解析output为输出源intput为输入源filter为滤镜 以下为滤镜，添加了部分注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// Filters#import &quot;GPUImageFilter.h&quot;#import &quot;GPUImageTwoInputFilter.h&quot;#import &quot;GPUImagePixellateFilter.h&quot; //像素化#import &quot;GPUImagePixellatePositionFilter.h&quot;#import &quot;GPUImageSepiaFilter.h&quot; // 褐色（怀旧）#import &quot;GPUImageColorInvertFilter.h&quot; // 反色#import &quot;GPUImageSaturationFilter.h&quot; // 饱和度#import &quot;GPUImageContrastFilter.h&quot; // 对比度#import &quot;GPUImageExposureFilter.h&quot; // 曝光#import &quot;GPUImageBrightnessFilter.h&quot; // 亮度 #import &quot;GPUImageLevelsFilter.h&quot; // 色阶#import &quot;GPUImageSharpenFilter.h&quot; //锐化#import &quot;GPUImageGammaFilter.h&quot; //gamma：要应用的灰度调整（0.0 - 3.0，默认为1.0）#import &quot;GPUImageSobelEdgeDetectionFilter.h&quot; //Sobel边缘检测算法(白边，黑内容，有点漫画的反色效果)#import &quot;GPUImageSketchFilter.h&quot; //素描#import &quot;GPUImageToonFilter.h&quot; //卡通效果（黑色粗线描边）#import &quot;GPUImageSmoothToonFilter.h&quot; //相比上面的效果更细腻，上面是粗旷的画风#import &quot;GPUImageMultiplyBlendFilter.h&quot; //通常用于创建阴影和深度效果#import &quot;GPUImageDissolveBlendFilter.h&quot; //溶解#import &quot;GPUImageKuwaharaFilter.h&quot; //桑原(Kuwahara)滤波,水粉画的模糊效果；处理时间比较长，慎用#import &quot;GPUImageKuwaharaRadius3Filter.h&quot;#import &quot;GPUImageVignetteFilter.h&quot; //晕影，形成黑色圆形边缘，突出中间图像的效果#import &quot;GPUImageGaussianBlurFilter.h&quot; //高斯模糊#import &quot;GPUImageGaussianBlurPositionFilter.h&quot;#import &quot;GPUImageGaussianSelectiveBlurFilter.h&quot; //高斯模糊，选择部分清晰#import &quot;GPUImageOverlayBlendFilter.h&quot; //叠加,通常用于创建阴影效果#import &quot;GPUImageDarkenBlendFilter.h&quot; //加深混合,通常用于重叠类型#import &quot;GPUImageLightenBlendFilter.h&quot; //减淡混合,通常用于重叠类型#import &quot;GPUImageSwirlFilter.h&quot; //漩涡，中间形成卷曲的画面#import &quot;GPUImageSourceOverBlendFilter.h&quot; //源混合#import &quot;GPUImageColorBurnBlendFilter.h&quot; //色彩加深混合#import &quot;GPUImageColorDodgeBlendFilter.h&quot; //色彩减淡混合#import &quot;GPUImageScreenBlendFilter.h&quot; //屏幕包裹,通常用于创建亮点和镜头眩光#import &quot;GPUImageExclusionBlendFilter.h&quot; //排除混合#import &quot;GPUImageDifferenceBlendFilter.h&quot; //差异混合,通常用于创建更多变动的颜色#import &quot;GPUImageSubtractBlendFilter.h&quot; //差值混合,通常用于创建两个图像之间的动画变暗模糊效果#import &quot;GPUImageHardLightBlendFilter.h&quot; //强光混合,通常用于创建阴影效果#import &quot;GPUImageSoftLightBlendFilter.h&quot; //柔光混合#import &quot;GPUImageColorBlendFilter.h&quot;#import &quot;GPUImageHueBlendFilter.h&quot;#import &quot;GPUImageSaturationBlendFilter.h&quot;#import &quot;GPUImageLuminosityBlendFilter.h&quot;#import &quot;GPUImageCropFilter.h&quot; //剪裁#import &quot;GPUImageGrayscaleFilter.h&quot; // 灰度#import &quot;GPUImageTransformFilter.h&quot; //形状变化#import &quot;GPUImageChromaKeyBlendFilter.h&quot; //色度键混合#import &quot;GPUImageHazeFilter.h&quot; //朦胧加暗#import &quot;GPUImageLuminanceThresholdFilter.h&quot; //亮度阈#import &quot;GPUImagePosterizeFilter.h&quot; //色调分离，形成噪点效果#import &quot;GPUImageBoxBlurFilter.h&quot; //盒状模糊#import &quot;GPUImageAdaptiveThresholdFilter.h&quot; //自适应阈值#import &quot;GPUImageUnsharpMaskFilter.h&quot;#import &quot;GPUImageBulgeDistortionFilter.h&quot; //凸起失真，鱼眼效果#import &quot;GPUImagePinchDistortionFilter.h&quot; //收缩失真，凹面镜#import &quot;GPUImageCrosshatchFilter.h&quot; //交叉线阴影，形成黑白网状画面#import &quot;GPUImageCGAColorspaceFilter.h&quot; //CGA色彩滤镜，形成黑、浅蓝、紫色块的画面#import &quot;GPUImagePolarPixellateFilter.h&quot; //同心圆像素化#import &quot;GPUImageStretchDistortionFilter.h&quot; //伸展失真，哈哈镜#import &quot;GPUImagePerlinNoiseFilter.h&quot; //柏林噪点，花边噪点#import &quot;GPUImageJFAVoronoiFilter.h&quot;#import &quot;GPUImageVoronoiConsumerFilter.h&quot;#import &quot;GPUImageMosaicFilter.h&quot; //黑白马赛克#import &quot;GPUImageTiltShiftFilter.h&quot; //条纹模糊，中间清晰，上下两端模糊#import &quot;GPUImage3x3ConvolutionFilter.h&quot; //3x3卷积，高亮大色块变黑，加亮边缘、线条等#import &quot;GPUImageEmbossFilter.h&quot; //浮雕效果，带有点3d的感觉#import &quot;GPUImageCannyEdgeDetectionFilter.h&quot; //Canny边缘检测算法#import &quot;GPUImageThresholdEdgeDetectionFilter.h&quot; //阈值边缘检测（效果与上差别不大）#import &quot;GPUImageMaskFilter.h&quot; //遮罩混合#import &quot;GPUImageHistogramFilter.h&quot; // 色彩直方图，显示在图片上#import &quot;GPUImageHistogramGenerator.h&quot; // 色彩直方图#import &quot;GPUImageHistogramEqualizationFilter.h&quot;#import &quot;GPUImagePrewittEdgeDetectionFilter.h&quot; //普瑞维特(Prewitt)边缘检测(效果与Sobel差不多，貌似更平滑)#import &quot;GPUImageXYDerivativeFilter.h&quot; //XYDerivative边缘检测，画面以蓝色为主，绿色为边缘，带彩色#import &quot;GPUImageHarrisCornerDetectionFilter.h&quot; //Harris角点检测，会有绿色小十字显示在图片角点处#import &quot;GPUImageAlphaBlendFilter.h&quot; //透明混合,通常用于在背景上应用前景的透明度#import &quot;GPUImageNormalBlendFilter.h&quot; //正常#import &quot;GPUImageNonMaximumSuppressionFilter.h&quot; //非最大抑制，只显示亮度最高的像素，其他为黑#import &quot;GPUImageRGBFilter.h&quot; // RGB#import &quot;GPUImageMedianFilter.h&quot; //中间值，有种稍微模糊边缘的效果#import &quot;GPUImageBilateralFilter.h&quot; //双边模糊#import &quot;GPUImageCrosshairGenerator.h&quot; //十字#import &quot;GPUImageToneCurveFilter.h&quot; // 色调曲线#import &quot;GPUImageNobleCornerDetectionFilter.h&quot; //Noble角点检测，检测点更多#import &quot;GPUImageShiTomasiFeatureDetectionFilter.h&quot; //ShiTomasi角点检测，与上差别不大#import &quot;GPUImageErosionFilter.h&quot; //侵蚀边缘模糊，变黑白#import &quot;GPUImageRGBErosionFilter.h&quot; //RGB侵蚀边缘模糊，有色彩#import &quot;GPUImageDilationFilter.h&quot; //扩展边缘模糊，变黑白#import &quot;GPUImageRGBDilationFilter.h&quot; //RGB扩展边缘模糊，有色彩#import &quot;GPUImageOpeningFilter.h&quot; //黑白色调模糊#import &quot;GPUImageRGBOpeningFilter.h&quot; //RGB扩展边缘模糊，有色彩#import &quot;GPUImageClosingFilter.h&quot; //黑白色调模糊，暗色会被提亮#import &quot;GPUImageRGBClosingFilter.h&quot; //彩色模糊，暗色会被提亮#import &quot;GPUImageColorPackingFilter.h&quot; //色彩丢失，模糊（类似监控摄像效果）#import &quot;GPUImageSphereRefractionFilter.h&quot; //球形折射，图形倒立#import &quot;GPUImageMonochromeFilter.h&quot; // 单色#import &quot;GPUImageOpacityFilter.h&quot; // 不透明度#import &quot;GPUImageHighlightShadowFilter.h&quot; // 提亮阴影#import &quot;GPUImageFalseColorFilter.h&quot; // 色彩替换（替换亮部和暗部色彩）#import &quot;GPUImageHSBFilter.h&quot;#import &quot;GPUImageHueFilter.h&quot; //色度#import &quot;GPUImageGlassSphereFilter.h&quot; //水晶球效果#import &quot;GPUImageLookupFilter.h&quot; //lookup 色彩调整#import &quot;GPUImageAmatorkaFilter.h&quot; //Amatorka lookup#import &quot;GPUImageMissEtikateFilter.h&quot; //MissEtikate lookup#import &quot;GPUImageSoftEleganceFilter.h&quot; //SoftElegance lookup#import &quot;GPUImageAddBlendFilter.h&quot; //通常用于创建两个图像之间的动画变亮模糊效果#import &quot;GPUImageDivideBlendFilter.h&quot; //通常用于创建两个图像之间的动画变暗模糊效果#import &quot;GPUImagePolkaDotFilter.h&quot; //像素圆点花样#import &quot;GPUImageLocalBinaryPatternFilter.h&quot; //图像黑白化，并有大量噪点#import &quot;GPUImageLanczosResamplingFilter.h&quot; //Lanczos重取样，模糊效果#import &quot;GPUImageAverageColor.h&quot; //像素平均色值#import &quot;GPUImageSolidColorGenerator.h&quot; //纯色#import &quot;GPUImageLuminosity.h&quot; //亮度平均#import &quot;GPUImageAverageLuminanceThresholdFilter.h&quot; //像素色值亮度平均，图像黑白（有类似漫画效果）#import &quot;GPUImageWhiteBalanceFilter.h&quot; //白平横#import &quot;GPUImageChromaKeyFilter.h&quot; //色度键#import &quot;GPUImageLowPassFilter.h&quot; //用于图像加亮#import &quot;GPUImageHighPassFilter.h&quot; //图像低于某值时显示为黑#import &quot;GPUImageMotionDetector.h&quot; //动作检测#import &quot;GPUImageHalftoneFilter.h&quot; //点染,图像黑白化，由黑点构成原图的大致图形#import &quot;GPUImageThresholdedNonMaximumSuppressionFilter.h&quot; //非最大抑制，只显示亮度最高的像素，其他为黑，像素丢失更多#import &quot;GPUImageHoughTransformLineDetector.h&quot; //线条检测#import &quot;GPUImageParallelCoordinateLineTransformFilter.h&quot; //平行线检测#import &quot;GPUImageThresholdSketchFilter.h&quot; //阀值素描，形成有噪点的素描#import &quot;GPUImageLineGenerator.h&quot; // 线条#import &quot;GPUImageLinearBurnBlendFilter.h&quot;#import &quot;GPUImageGaussianBlurPositionFilter.h&quot;#import &quot;GPUImagePixellatePositionFilter.h&quot;#import &quot;GPUImageTwoInputCrossTextureSamplingFilter.h&quot;#import &quot;GPUImagePoissonBlendFilter.h&quot;#import &quot;GPUImageMotionBlurFilter.h&quot;#import &quot;GPUImageZoomBlurFilter.h&quot;#import &quot;GPUImageLaplacianFilter.h&quot;#import &quot;GPUImageiOSBlurFilter.h&quot;#import &quot;GPUImageLuminanceRangeFilter.h&quot;#import &quot;GPUImageDirectionalNonMaximumSuppressionFilter.h&quot;#import &quot;GPUImageDirectionalSobelEdgeDetectionFilter.h&quot;#import &quot;GPUImageSingleComponentGaussianBlurFilter.h&quot;#import &quot;GPUImageThreeInputFilter.h&quot;#import &quot;GPUImageWeakPixelInclusionFilter.h&quot; 代码传送门 简书 掘金 ps: 大神请轻喷，如果觉得还行，请点个star，谢谢！]]></content>
      <categories>
        <category>IT技能</category>
      </categories>
      <tags>
        <tag>滤镜</tag>
        <tag>GPUImage</tag>
        <tag>颜色</tag>
        <tag>Filter</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多级Push页面后优雅的返回指定控制器几种方法]]></title>
    <url>%2F10633.html</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开发过程中我们可能会遇到不同的产品需求，例如说A–&gt;B–C，如果是层级返回的话我们只需要pop回去就好，但是如果是back到指定VC的时候，例如：A–&gt;B–C，然后从C回到A，在开发过程中还是遇到的比较多的，本文总结了常见的三种方法，以此记录一下。 使用场景： A – &gt; B – &gt; C，然后现在要求C直接pop回到A。 方法一 C返回到B的时候写个回调，B接收到回调再自己pop到A，但是这个方法B的页面会闪现一下，用户体验不好，不推荐。 实现代码：C_ViewController.h1234567#import &lt;UIKit/UIKit.h&gt;typedef void (^backBlock)(void); @interface C_ViewController : UIViewController@property (copy,nonatomic)backBlock backBlock;@end C_ViewController.m123456789-(void)back&#123; if (self.backBlock) &#123; [self.navigationController popViewControllerAnimated:YES]; self.backBlock(); &#125;&#125; B_ViewController实现方法12345C_ViewController *cViewController = [[C_ViewController alloc] init]; [self.navigationController pushViewController:cViewController animated:YES]; cViewController.backBlock = ^&#123; [self.navigationController popViewControllerAnimated:YES]; &#125;; 方法二 在B push 到C的时候，直接把B从导航控制器的堆栈中移除。 实现方法：B_ViewController实现方法1234// 方法二NSMutableArray *arrM = [[NSMutableArray alloc] initWithArray:self.navigationController.viewControllers];[arrM replaceObjectAtIndex:[arrM count]-1 withObject:cViewController];[self.navigationController setViewControllers:arrM animated:YES]; 方法三 写一个UIViewController的catrgory，在C的backAct方法中使用 实现方法：UIViewController+BackToViewController.h12345#import &lt;UIKit/UIKit.h&gt;@interface UIViewController (BackToViewController)-(void)backToController:(NSString *)controllerName animated:(BOOL )animaed;@end UIViewController+BackToViewController.m123456789101112@implementation UIViewController (BackToViewController)-(void)backToController:(NSString *)controllerName animated:(BOOL)animaed&#123; if (self.navigationController) &#123; NSArray *controllers = self.navigationController.viewControllers; NSArray *result = [controllers filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(id _Nullable evaluatedObject, NSDictionary&lt;NSString *,id&gt; * _Nullable bindings) &#123; return [evaluatedObject isKindOfClass:NSClassFromString(controllerName)]; &#125;]]; if (result.count &gt; 0) &#123; [self.navigationController popToViewController:result[0] animated:YES]; &#125; &#125;&#125; 在C_ViewController中使用 123456789// 方法三 if(self.navigationController.viewControllers.count &lt;= 1) &#123; [self dismissViewControllerAnimated:YES completion:nil]; &#125; else &#123; [self backToController:@&quot;ViewController&quot; animated:YES]; &#125; 这是我个人用的三种方法，比较推荐第三种方法，如有更好的方法麻烦告知，大家共同进步，谢谢。 代码传送门]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS程序异常Crash友好化处理]]></title>
    <url>%2F1258.html</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前两天接到个面试，面试官问到上线的app怎么避免闪退，首先想到的就是在编码的时候进行各种容错，但貌似并不是面试官想要的答案，所以表现的很糟糕。今天有时间就来整理一下，希望有所帮助。实现效果如图： 效果实现： 用法：1.将截图的中12.在```AppDelegate.m```中找到以下方法并如下添加代码： (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions { // Override point for customization after application launch. [UncaughtExceptionHandler installUncaughtExceptionHandler:YES showAlert:YES]; return YES;} 123以上代码就可以实现稍微友好一点的crash拦截处理。## 代码解释：```UncaughtExceptionHandler.h```主要代码： #import &lt;Foundation/Foundation.h&gt; #import &lt;UIKit/UIKit.h&gt; @interface UncaughtExceptionHandler : NSObject /*! 异常的处理方法* @param install 是否开启捕获异常 @param showAlert 是否在发生异常时弹出alertView*/ (void)installUncaughtExceptionHandler:(BOOL)install showAlert:(BOOL)showAlert;@end12```UncaughtExceptionHandler.m```文件主要的代码如下：#### 1.发送异常信号 /* 异常的处理方法* @param install 是否开启捕获异常 @param showAlert 是否在发生异常时弹出alertView*/ (void)installUncaughtExceptionHandler:(BOOL)install showAlert:(BOOL)showAlert { if (install &amp;&amp; showAlert) { [[self alloc] alertView:showAlert]; } NSSetUncaughtExceptionHandler(install ? HandleException : NULL);signal(SIGABRT, install ? SignalHandler : SIG_DFL);signal(SIGILL, install ? SignalHandler : SIG_DFL);signal(SIGSEGV, install ? SignalHandler : SIG_DFL);signal(SIGFPE, install ? SignalHandler : SIG_DFL);signal(SIGBUS, install ? SignalHandler : SIG_DFL);signal(SIGPIPE, install ? SignalHandler : SIG_DFL);} 1234 产生上述的signal的时候就会调用我们定义的```SignalHandler```来处理异常。 &gt; ps: NSSetUncaughtExceptionHandler就是iOS SDK中提供的一个现成的函数,用来捕获异常的方法，使用方便。但它不能捕获抛出的signal，所以定义了SignalHandler方法。#### 2.处理异常 void HandleException(NSException *exception) { int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount); // 如果太多不用处理 if (exceptionCount &gt; UncaughtExceptionMaximum) { return; } //获取调用堆栈 NSArray *callStack = [exception callStackSymbols]; NSMutableDictionary *userInfo = [NSMutableDictionary dictionaryWithDictionary:[exception userInfo]]; [userInfo setObject:callStack forKey:UncaughtExceptionHandlerAddressesKey]; //在主线程中，执行制定的方法, withObject是执行方法传入的参数 [[[UncaughtExceptionHandler alloc] init] performSelectorOnMainThread:@selector(handleException:) withObject: [NSException exceptionWithName:[exception name] reason:[exception reason] userInfo:userInfo] waitUntilDone:YES]; } 12该方法就是对应```NSSetUncaughtExceptionHandler```的处理，只要方法关联到这个函数，那么发生相应错误时会自动调用该函数，调用时会传入```exception```参数。获取异常后会将捕获的异常传入最终调用处理的```handleException```函数。#### 3.无法捕获的signal处理 //处理signal报错void SignalHandler(int signal) { int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount); // 如果太多不用处理 if (exceptionCount &gt; UncaughtExceptionMaximum) { return; } NSString* description = nil; switch (signal) { case SIGABRT: description = [NSString stringWithFormat:@&quot;Signal SIGABRT was raised!\n&quot;]; break; case SIGILL: description = [NSString stringWithFormat:@&quot;Signal SIGILL was raised!\n&quot;]; break; case SIGSEGV: description = [NSString stringWithFormat:@&quot;Signal SIGSEGV was raised!\n&quot;]; break; case SIGFPE: description = [NSString stringWithFormat:@&quot;Signal SIGFPE was raised!\n&quot;]; break; case SIGBUS: description = [NSString stringWithFormat:@&quot;Signal SIGBUS was raised!\n&quot;]; break; case SIGPIPE: description = [NSString stringWithFormat:@&quot;Signal SIGPIPE was raised!\n&quot;]; break; default: description = [NSString stringWithFormat:@&quot;Signal %d was raised!&quot;,signal]; } NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; NSArray *callStack = [UncaughtExceptionHandler backtrace]; [userInfo setObject:callStack forKey:UncaughtExceptionHandlerAddressesKey]; [userInfo setObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey]; //在主线程中，执行指定的方法, withObject是执行方法传入的参数 [[[UncaughtExceptionHandler alloc] init] performSelectorOnMainThread:@selector(handleException:) withObject: [NSException exceptionWithName:UncaughtExceptionHandlerSignalExceptionName reason: description userInfo: userInfo] waitUntilDone:YES]; } 12以上方法是对于捕获不到的signal信号进行处理，列出常见的异常类型。#### 4.堆栈调用 //获取调用堆栈 (NSArray *)backtrace { //指针列表 void callstack[128]; //backtrace用来获取当前线程的调用堆栈，获取的信息存放在这里的callstack中 //128用来指定当前的buffer中可以保存多少个void元素 //返回值是实际获取的指针个数 int frames = backtrace(callstack, 128); //backtrace_symbols将从backtrace函数获取的信息转化为一个字符串数组 //返回一个指向字符串数组的指针 //每个字符串包含了一个相对于callstack中对应元素的可打印信息，包括函数名、偏移地址、实际返回地址 char **strs = backtrace_symbols(callstack, frames); int i; NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames]; for (i = 0; i &lt; frames; i++) { [backtrace addObject:[NSString stringWithUTF8String:strs[i]]]; } free(strs); return backtrace;} 12&gt; backtrace是Linux下用来追踪函数调用堆栈以及定位段错误的函数。#### 5.使用UIAlerView进行友好化提示 (void)handleException:(NSException *)exception { [self validateAndSaveCriticalApplicationData:exception]; if (!showAlertView) { return; } #pragma clang diagnostic push #pragma clang diagnostic ignored “-Wdeprecated-declarations” UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@”出错啦” message:[NSString stringWithFormat:@”你可以尝试继续操作，但是应用可能无法正常运行.\n”] delegate:self cancelButtonTitle:@”退出” otherButtonTitles:@”继续”, nil]; [alert show]; #pragma clang diagnostic pop CFRunLoopRef runLoop = CFRunLoopGetCurrent(); CFArrayRef allModes = CFRunLoopCopyAllModes(runLoop); while (!self.dismissed) { //点击继续 for (NSString *mode in (__bridge NSArray *)allModes) { //快速切换Mode CFRunLoopRunInMode((CFStringRef)mode, 0.001, false); } } //点击退出 CFRelease(allModes); NSSetUncaughtExceptionHandler(NULL); signal(SIGABRT, SIG_DFL); signal(SIGILL, SIG_DFL); signal(SIGSEGV, SIG_DFL); signal(SIGFPE, SIG_DFL); signal(SIGBUS, SIG_DFL); signal(SIGPIPE, SIG_DFL); if ([[exception name] isEqual:UncaughtExceptionHandlerSignalExceptionName]) { kill(getpid(), [[[exception userInfo] objectForKey:UncaughtExceptionHandlerSignalKey] intValue]); } else { [exception raise]; } }` 在这里你可以做自己的crash收集操作，例如上传服务器等。 最后，我想说对网上给的这个拦截处理个人理解的不是很透彻，借鉴了多位大牛的技术分享，如果有新的解决方案，麻烦评论告诉我，大家一起共同进步。本文已同步至本人博客 代码传送门更多文章]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>Carsh</tag>
        <tag>崩溃拦截</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中优雅的使用iconfont]]></title>
    <url>%2F20558.html</url>
    <content type="text"><![CDATA[1.什么是iconfont&ensp;&ensp;&ensp;&ensp;iconFont拆开来看，就是 Icon + Font，这样估计大家应该都能理解是什么，那两者结合是什么呢？没错！就是 IconFont ！让开发者像使用字体一样使用图标。如果自己不会做的话，可以直接去阿里的iconfont图标库下载自己需要的图标。 2.为什么要使用iconfont&ensp;&ensp;&ensp;&ensp;在开发项目时，不可避免的会用到各种图标，为了适配不同的设备，通常需要@2x和@3x两套图，例如说我们tabBar上使用的图标。有些app有换肤的需要，还需要多套不同的图来进行匹配不同的主题。如果使用切图，这对于设计和开发来说无疑是增加了工作量，而且ipa的体积也会增大。 使用iconfont的好处: 减小ipa包的大小 图标保真缩放，多设备适配一套图解决问题 适应换肤要求，使用方便。 3.怎么用iconfont1. 首先去iconfont图标库下载自己需要的图标。 如图我们可以选择自己需要的icon加入到购物车，然后加入项目里，当然你也可以直接在购物车直接下载，但是这样只是没有修改icon为自己想要的样式，加入项目中，你可以自己任意修改icon为自己想要的样式。 注意：这里是下载代码，这样我们就可以在项目中直接使用 2.将下载下来的icon资源添加到自己的项目中。我们所需要的就是这个iconfont.ttf，对于这个ttf文件，我想我们并不陌生吧。新建项目，将这个ttf文件拖入自己的项目里。 注意：勾选如图选项 接下来配置项目加载这个文件 检查文件是否在项目中，不然会崩溃 在plist文件中加入字体接下来我们借助淘点点科技写的一个关于iconfont封装，方便我们使用iconfont。iconfont的封装包括 TBCityIconInfo.h的实现 12345678910111213#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@interface TBCityIconInfo : NSObject@property (nonatomic, strong) NSString *text;@property (nonatomic, assign) NSInteger size;@property (nonatomic, strong) UIColor *color;- (instancetype)initWithText:(NSString *)text size:(NSInteger)size color:(UIColor *)color;+ (instancetype)iconInfoWithText:(NSString *)text size:(NSInteger)size color:(UIColor *)color;@end TBCityIconInfo.m的实现 123456789101112131415161718#import &quot;TBCityIconInfo.h&quot;@implementation TBCityIconInfo- (instancetype)initWithText:(NSString *)text size:(NSInteger)size color:(UIColor *)color &#123;if (self = [super init]) &#123;self.text = text;self.size = size;self.color = color;&#125;return self;&#125;+ (instancetype)iconInfoWithText:(NSString *)text size:(NSInteger)size color:(UIColor *)color &#123;return [[TBCityIconInfo alloc] initWithText:text size:size color:color];&#125;@end TBCityIconFont.h的实现 123456789#import &quot;UIImage+TBCityIconFont.h&quot;#import &quot;TBCityIconInfo.h&quot;#define TBCityIconInfoMake(text, imageSize, imageColor) [TBCityIconInfo iconInfoWithText:text size:imageSize color:imageColor]@interface TBCityIconFont : NSObject+ (UIFont *)fontWithSize: (CGFloat)size;+ (void)setFontName:(NSString *)fontName; TBCityIconFont.m的实现 1234567891011121314151617181920212223242526272829303132333435363738#import &quot;TBCityIconFont.h&quot;#import &lt;CoreText/CoreText.h&gt;@implementation TBCityIconFontstatic NSString *_fontName;+ (void)registerFontWithURL:(NSURL *)url &#123;NSAssert([[NSFileManager defaultManager] fileExistsAtPath:[url path]], @&quot;Font file doesn&apos;t exist&quot;);CGDataProviderRef fontDataProvider = CGDataProviderCreateWithURL((__bridge CFURLRef)url);CGFontRef newFont = CGFontCreateWithDataProvider(fontDataProvider);CGDataProviderRelease(fontDataProvider);CTFontManagerRegisterGraphicsFont(newFont, nil);CGFontRelease(newFont);&#125;+ (UIFont *)fontWithSize:(CGFloat)size &#123;UIFont *font = [UIFont fontWithName:[self fontName] size:size];if (font == nil) &#123;NSURL *fontFileUrl = [[NSBundle mainBundle] URLForResource:[self fontName] withExtension:@&quot;ttf&quot;];[self registerFontWithURL: fontFileUrl];font = [UIFont fontWithName:[self fontName] size:size];NSAssert(font, @&quot;UIFont object should not be nil, check if the font file is added to the application bundle and you&apos;re using the correct font name.&quot;);&#125;return font;&#125;+ (void)setFontName:(NSString *)fontName &#123;_fontName = fontName;&#125;+ (NSString *)fontName &#123;return _fontName ? : @&quot;iconfont&quot;;&#125;@end UIImage+TBCityIconFont.h的实现 12345678#import &lt;UIKit/UIKit.h&gt;#import &quot;TBCityIconInfo.h&quot;@interface UIImage (TBCityIconFont)+ (UIImage *)iconWithInfo:(TBCityIconInfo *)info;@end UIImage+TBCityIconFont.m的实现 123456789101112131415161718192021222324252627282930313233343536#import &quot;UIImage+TBCityIconFont.h&quot;#import &quot;TBCityIconFont.h&quot;#import &lt;CoreText/CoreText.h&gt;@implementation UIImage (TBCityIconFont)+ (UIImage *)iconWithInfo:(TBCityIconInfo *)info &#123;CGFloat size = info.size;CGFloat scale = [UIScreen mainScreen].scale;CGFloat realSize = size * scale;UIFont *font = [TBCityIconFont fontWithSize:realSize];UIGraphicsBeginImageContext(CGSizeMake(realSize, realSize));CGContextRef context = UIGraphicsGetCurrentContext();if ([info.text respondsToSelector:@selector(drawAtPoint:withAttributes:)]) &#123;/*** 如果这里抛出异常，请打开断点列表，右击All Exceptions -&gt; Edit Breakpoint -&gt; All修改为Objective-C* See: http://stackoverflow.com/questions/1163981/how-to-add-a-breakpoint-to-objc-exception-throw/14767076#14767076*/[info.text drawAtPoint:CGPointZero withAttributes:@&#123;NSFontAttributeName:font, NSForegroundColorAttributeName: info.color&#125;];&#125; else &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;CGContextSetFillColorWithColor(context, info.color.CGColor);[info.text drawAtPoint:CGPointMake(0, 0) withFont:font];#pragma clang pop&#125;UIImage *image = [UIImage imageWithCGImage:UIGraphicsGetImageFromCurrentImageContext().CGImage scale:scale orientation:UIImageOrientationUp];UIGraphicsEndImageContext();return image;&#125;@end 3.具体使用方法1.在AppDelegate.m中，初始化iconfont123456789101112131415161718#import &quot;AppDelegate.h&quot;#import &quot;TBCityIconFont.h&quot;#import &quot;ViewController.h&quot;@interface AppDelegate ()@end@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;// Override point for customization after application launch.[TBCityIconFont setFontName:@&quot;iconfont&quot;];UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:[ViewController new]];self.window.rootViewController = nav;[self.window makeKeyAndVisible];return YES;&#125; 在ViewController.m中实现12345678910111213141516171819202122232425262728293031323334353637383940414243#import &quot;ViewController.h&quot;#import &quot;TBCityIconFont.h&quot;#import &quot;UIImage+TBCityIconFont.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];self.view.backgroundColor = [UIColor whiteColor];UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 30, 30)];[self.view addSubview:imageView];//图标编码是&amp;#xe600，需要转成\U0000e600imageView.image = [UIImage iconWithInfo:TBCityIconInfoMake(@&quot;\U0000e600&quot;, 30, [UIColor redColor])];// buttonUIButton *button = [UIButton buttonWithType:UIButtonTypeSystem];button.frame = CGRectMake(100, 150, 40, 40);[self.view addSubview:button];[button setImage:[UIImage iconWithInfo:TBCityIconInfoMake(@&quot;\U0000e614&quot;, 40, [UIColor redColor])] forState:UIControlStateNormal];// label,label可以将文字与图标结合一起，直接用label的text属性将图标显示出来UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(50, 200, 280, 40)];[self.view addSubview:label];label.font = [UIFont fontWithName:@&quot;iconfont&quot; size:15];//设置label的字体label.text = @&quot;在lable上显示 \U0000e658&quot;;// Do any additional setup after loading the view, typically from a nib.&#125;- (void)didReceiveMemoryWarning &#123;[super didReceiveMemoryWarning];// Dispose of any resources that can be recreated.&#125;@end 结果如下图所示： 注意： 所用到的unicode编码需要自己手动将&amp;#xXXXX格式转换成\UXXXXXXXX格式，例如//图标编码是&amp;#xe600，需要转成\U0000e600 所有需要的unicode编码都可以在下载的iconfont文件夹中的.html文件打开查看 本文demo,欢迎批评指正，留下你的star哦。]]></content>
      <tags>
        <tag>ios</tag>
        <tag>iconfont</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reveal---iOS项目UI调试工具使用教程]]></title>
    <url>%2F1581.html</url>
    <content type="text"><![CDATA[一、Reveal介绍 Reveal是Mac os平台上的一款开发者调试IOS应用的Mac[开发软件]reveal Mac版它能够在运行时调试和修改iOS应用程序。Reveal能连接到应用程序，并允许开发者编辑各种用户界面参数，这反过来会立即反应在程序的UI上。Reveal 在 官网售价119美元，约合人民币1280元]，（文末会给出破解版的下载地址，当然，要支持正版哟^_^）。 二、Reveal集成使用1、下载安装Reveal，直接安装。如果提示xxx.app文件损坏打不开，请参考我的另一篇文章解决，这里了就不多说了。 2、找到你刚才安装的软件,打开主界面显示如下图 3、在你的项目中集成（1）创建一个名为RevealTestDemo的项目,导入CocoPods,打开Podfile文件输入12// :configurations =&gt; [&apos;Debug&apos;] 只是在xcode debug 时才会加入；pod &apos;Reveal-SDK&apos;, :git =&gt; &apos;https://git.coding.net/kakukeme/Reveal-SDK.git&apos;, :configurations =&gt; [&apos;Debug&apos;] （2）、Xcode打开项目，并运行 在界面上添加一个背景颜色为红色的label,这个时候打开Reveal,你就能看到点击进入就能看到 4、功能分析窗口介绍点击一个控件之后进入这个子控件的详细信息 在属性窗口里面我们能很清晰的看见这个控件的相关信息，包括Frame等，同时你还可以直接在属性面板进行修改控件的信息 修改前修改后 是不是很方便，修改字体、颜色、大小、对齐方式等都可以在属性面板进行操作，很直观的看到修改后的效果，不幸的是，你项目中的代码还需要自己去修改（据说后期版本会有对这一方面的修改，期待ing）。本文Demo地址,Reveal下载地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[Xcode9-Safe-Area-Layout-Guide-Before-iOS9-0报错解决]]></title>
    <url>%2F45450.html</url>
    <content type="text"><![CDATA[9月20日苹果爸爸推送了iOS11.0以及Xcode9,作为开发小白一枚，第一时间更新了Xcode9,去体验一下所谓的跨时代的iPhone X,像往常新建个新项目，结果一运行直接报错（弱弱的说一句，这个xcode9好像并没有那么友好~）然后一Google，苹果爸爸在苹果在iOS7中引入的Top Layout Guide和Bottom Layout Guide,这些布局指南在iOS 11中被弃用，取而代之的是Safe Area Layout Guide.针对新特性，解决方案如下第一步、在项目报错地方打开右边工具栏找到如图位置选中View Controller，去掉Use Safe Area Layout Guides 第二步、切换到Main.storyboard文件,重读第一步操作打开右边工具栏找到如图位置选中View Controller，去掉Use Safe Area Layout Guides 到这就解决了这个问题，当然iOS11和Xcode9还有其他新特性，一点点整理解决。]]></content>
      <categories>
        <category>Xcode</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
        <tag>自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableViewCell高度自适应--Xib和Masonry布局]]></title>
    <url>%2F18602.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS微信支付以及工具类]]></title>
    <url>%2F21387.html</url>
    <content type="text"><![CDATA[在刚刚结束的一个项目中用到了微信支付，从接入微信支付到工具类的封装，在本文中做个积累，方便日后使用。 1.开始接入微信支付的准备工作 首先你需要去微信开放平台注册账号,在这里要吐槽一下，不知道这个微信平台的账号密码验证机制，忘了以前的密码，重新登录，各种找回密码都不行，实在没辙，去注册个Gmail😑，登录成功后，可以看到如下界面。 点击右上角的创建移动应用，一步一步填写必要填入的信息，在这里就不做多余的赘述了。需要注意的是这里填入的Bundle ID需要和项目的一一对应接下来就等一个星期左右，等待微信审核通过你就可以将微信支付SDK集成到项目中，详情可以看官方给出的文档.pod 集成方法1pod &apos;WechatOpenSDK&apos; 在Xcode中，选择你的工程设置项，选中“TARGETS”一栏，在“info”标签栏的“URL type“添加“URL scheme”为你所注册的应用程序id（如下图所示）。 完成之后可以获取到appid(微信开放平台为应用生成的唯一识别码)、商户id、商户secretKey。对于app端来说只用到appid，商户id最好通过接口从server获取，商户secretKey是用来签名的，一般只有server能用到。 2.支付流程 刚开始看这个流程图可能会觉得很复杂，所以总结了我们比较关系的流程是： app客户端向服务器发送支付请求 服务器在收到客户端请求之后向微信后台调用统一下单API,获得预付单信息 服务端生成带签名的客户端支付信息给app app客户端用户确认支付，app唤醒微信客户端进行支付 app获得支付结果后向服务端查询最终的结果并显示 app端的工作： 接入微信支付SDK 向服务器发送支付请求 支付信息唤醒微信app,然后进行支付 收到微信支付回调后向服务器确认支付结果 根据查询结果展示结果页面告知用户支付结果 服务器端的工作： 收到app客户端支付请求后向微信后台请求预支付订单 服务器端签名并返回信息给app客户端 接收微信后台返回的支付结果，用来app端查询 服务器端返回的字段说明： appId:返回的appid partnerId: 父级id prepayId: 支付id packages: 包名（微信默认的为“Sign=WXPay”） nonceStr: 生成的随机字符串 timesTamp: 时间戳 sign: 签名 3.iOS端使用在AppDelegate.m,导入微信SDK头文件WXApi.h123456789101112131415161718192021- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;[WXApi registerApp:@&quot;注册获得的appid&quot;];//注册appidreturn YES;&#125;//支持所有iOS系统回调- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123;// [self handleOpenURL:url];BOOL result = [[UMSocialManager defaultManager] handleOpenURL:url sourceApplication:sourceApplication annotation:annotation];if (!result) &#123;// 其他如支付等SDK的回调[self handleOpenURL:url];&#125;return YES;&#125;- (void)handleOpenURL:(NSURL*)url &#123;if ([url.host isEqualToString:@&quot;pay&quot;]) &#123; // -- 微信支付[WXApi handleOpenURL:url delegate:[WXPayService sharedInstance]];&#125;&#125; 此处的WXPayService就是自己单独抽出来写的一个类，遵循WXApiManagerDelegate协议 WXPayService.h12345678910111213#import &lt;Foundation/Foundation.h&gt;#import &quot;WXApi.h&quot;@interface WXPayService : NSObject &lt;WXApiDelegate&gt;///单例来接收微信请求的回调+ (instancetype)sharedInstance;// -- 根据接口返回的预支付信息,构造支付请求+ (PayReq *)getPayRequest:(NSDictionary *)prepayData;///处理非支付请求的回调- (void)onRespCallBack:(void(^)(BaseResp * resp))callback;///从服务器端获取到微信返回的支付请求用到的参数来发起支付请求- (void)startPayWithReq:(PayReq *)req callback:(void(^)(BaseResp * resp))callback; @end WXPayService.m1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#import &quot;WXPayService.h&quot;@interface WXPayService ()@property (nonatomic,copy) void(^RespCallBack)(BaseResp *);@endstatic WXPayService *sharedInstance;@implementation WXPayService+ (instancetype)allocWithZone:(struct _NSZone *)zone&#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;sharedInstance = [super allocWithZone:zone];&#125;);return sharedInstance;&#125;///单例来接收微信请求的回调+ (instancetype)sharedInstance &#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;sharedInstance = [[self alloc] init];&#125;);return sharedInstance;&#125;// -- 根据接口返回的预支付信息,构造支付请求+ (PayReq *)getPayRequest:(NSDictionary *)prepayData &#123;if (prepayData) &#123;// 此处Tools是自己的另一个工具类，用来判断字典的PayReq *req = [[PayReq alloc] init];if ([Tools dicContain:prepayData withKey:@&quot;partnerid&quot;]) &#123;req.partnerId = prepayData[@&quot;partnerid&quot;];&#125;if ([Tools dicContain:prepayData withKey:@&quot;prepayid&quot;]) &#123;req.prepayId = prepayData[@&quot;prepayid&quot;];&#125;if ([Tools dicContain:prepayData withKey:@&quot;noncestr&quot;]) &#123;req.nonceStr = prepayData[@&quot;noncestr&quot;];&#125;if ([Tools dicContain:prepayData withKey:@&quot;timestamp&quot;]) &#123;req.timeStamp = [prepayData[@&quot;timestamp&quot;] intValue];&#125;req.package =@&quot;Sign=WXPay&quot;;req.sign = @&quot;null&quot;;//日志输出NSLog(@&quot;appid=%@/npartid=%@/nprepayid=%@/nnoncestr=%@/ntimestamp=%ld/npackage=%@/nsign=%@&quot;,[prepayData objectForKey:@&quot;appid&quot;],req.partnerId,req.prepayId,req.nonceStr,(long)req.timeStamp,req.package,req.sign);return req;&#125;return nil;&#125;///处理非支付请求的回调- (void)onRespCallBack:(void(^)(BaseResp * resp))callback &#123;self.RespCallBack = callback;&#125;///从服务器端获取到微信返回的支付请求用到的参数来发起支付请求- (void)startPayWithReq:(PayReq *)req callback:(void(^)(BaseResp * resp))callback &#123;NSAssert(req !=nil , @&quot;未成功创建微信支付请求&quot;);self.RespCallBack = callback;if ([WXApi isWXAppInstalled]) &#123; // -- 判断是否安装微信应用//发起微信支付,设置参数[WXApi sendReq:req];&#125;else &#123;self.RespCallBack(nil);&#125;&#125;#pragma mark WXApiDelegate- (void)onResp:(BaseResp *)resp &#123;if ([resp isKindOfClass:[PayResp class]]) &#123; // -- 判断是否为支付的回调self.RespCallBack(resp);&#125;&#125;@end 在需要支付的ViewController中导入工具类WXPayService 4.注意点及问题注意点： 设置好scheme,否则应用无法跳转到微信客户端 支付签名时的key值全部是小写的 如果支付显示验证签名失败的时候，可以将packages设为默认值(Sign=WXPay)试试 问题： 系统版本大于等于iOS9的，调起微信客户端之后，可以直接点击状态栏左侧按钮返回，这时是不走回调方法的。 解决方案：在AppDelegate.m的applicationWillEnterForeground方法中，调用查询支付结果接口然后刷新当然页面。需要设置bool变量作为标志，否则每次应用进入前台都去查询，就不符合业务要求了。 进入微信支付页面之后，不做操作，切换到自己应用中，退出当前支付页面，然后再进入微信客户端点击支付或者取消，此时自己的应用会崩溃闪退 原因：退出页面后页面已经出栈被销毁，但wx回调时还是去调用其中的代理方法，就会出现野指针。解决方案：在页面的viewWillDisappear方法中加入1[WXPayService sharedManager].delegate = nil; 5.结束语微信支付签名建议和服务端协商做二次签名，以保证支付的安全性。ps: 如有不对的地方，欢迎批评指正，另外安利一下个人的博客]]></content>
  </entry>
  <entry>
    <title><![CDATA[Charles抓包+Postman模拟请求]]></title>
    <url>%2F54645.html</url>
    <content type="text"><![CDATA[一、工具介绍1. Charles今天来介绍一下Mac上抓包工具Charles(又称为青花瓷)，官网可以下载，但是需要破解之后才能永久使用，当然，可以有30天试用期，具体的使用方法在此就不进行一一介绍了，如有需要再补上。（ps:破解版下载地址密码:meuk)。 2.PostmanPostman是一种网页调试与发送网页http请求的chrome插件。我们可以用来很方便的模拟get或者post或者其他方式的请求来调试接口。点击下载 二、开始抓取网络接口以及模拟请求第一步、打开Charles,在浏览器中输入需要请求的地址，我这里访问的是一个投票的接口显示信息如下：cookie信息：参数信息： 第二步、在第一步获取了请求的url、cookie、参数等请求需要的之后我们就可以打开Postman来进行模拟请求了。配置信息如下：body参数：第三步、发送请求，看到后台返回的信息到这里这个请求接口的操作就模拟成功了，既然参数和地址都有了，这个时候就是你想做什么就做什么的时候了，你懂得😆。 这是根据postman请求结果，自己随便写了个手机端来进行请求的，有兴趣的可以一起研究，欢迎骚扰。]]></content>
      <categories>
        <category>IT技能</category>
      </categories>
      <tags>
        <tag>抓包</tag>
        <tag>Charles</tag>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableViewCell上的输入框，输入不同内容]]></title>
    <url>%2F28824.html</url>
    <content type="text"><![CDATA[一、实现效果本文介绍怎么在UITableViewCell中添加输入框，对于不同的row的输入框输入的文本进行获取以至于打到一个表单填写的效果。 二、项目结构 三、代码部分1. 项目使用Cocoapods管理 在控制台对创建的项目进行创建pods，创建Podfile文件，使用命令vi Podfile进入到Podfile文件里面，按下键盘i进入编辑状态 输入我们需要使用的第三方库，此项目中使用了Masonry来进行适配 1234platform :ios, &apos;8.0&apos;target &apos;InputInfoDemo&apos; dopod &apos;Masonry&apos;end 在写好上一步的代码后，按ESC,然后输入:wq回车退出编辑状态 使用命令pod instal进行第三方库安装，当出现以下内容的时候表示你已经装好Masonry了######2.创建需要显示的自定义UITableViewCell**.h文件**1234567891011121314151617181920212223//// InputStrTableViewCell.h//// Created by Jackeroo on 2017/5/27.// Copyright © 2017年 Jackeroo. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;@interface InputStrTableViewCell : UITableViewCell@property (nonatomic, strong) UITextField *textField;/** 设置cell信息 @param title cell左侧标题 @param desc 占位文字信息 @param type 键盘类型 0、表示正常键盘 1、表示数字键盘 @param text 填充文字 @param textFieldBlock 输入内容回调 */-(void)setCellInfo:(NSString*)title withInputDesc:(NSString*)desc withKeybordType:(NSInteger )type withText:(NSString *)text WithReturnBlock:(void (^)(NSString *result))textFieldBlock;@end **.m文件**123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//// InputStrTableViewCell.m//// Created by Jackeroo on 2017/5/27.// Copyright © 2017年 Jackeroo. All rights reserved.//// 颜色#define RGBA(r,g,b,a) [UIColor colorWithRed:(r)/255.0f green:(g)/255.0f blue:(b)/255.0f alpha:a]#import &quot;InputStrTableViewCell.h&quot;#import &quot;Masonry.h&quot;#import &quot;View+MASShorthandAdditions.h&quot;@interface InputStrTableViewCell()&lt;UITextFieldDelegate&gt;// 标题Label@property (nonatomic, strong) UILabel *titleLabel;@end@implementation InputStrTableViewCell&#123;// 输入回调 void (^_block)(NSString *inputResult);&#125;- (void)awakeFromNib &#123; [super awakeFromNib]; // Initialization code&#125;// 初始化- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123; self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if (self) &#123; self.backgroundColor =RGBA(242, 242, 242, 1); self.selectionStyle = UITableViewCellSelectionStyleNone; self.titleLabel = [[UILabel alloc] init]; self.titleLabel.font =[UIFont systemFontOfSize:14]; self.titleLabel.textColor = [UIColor blackColor]; self.textField = [[UITextField alloc] init]; self.textField.font = [UIFont systemFontOfSize:12]; self.textField.textColor = [UIColor grayColor]; self.textField.textAlignment = NSTextAlignmentRight; self.textField.delegate = self; self.textField.backgroundColor = [UIColor whiteColor]; self.textField.clearButtonMode = UITextFieldViewModeAlways; // 添加输入完成会回调通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFieldChanging:) name:UITextFieldTextDidChangeNotification object:self.textField]; [self addSubview]; [self autoLayout]; CGFloat scale = [[UIScreen mainScreen] scale]; CGFloat width = scale &gt; 0.0 ? 1.0 / scale : 1.0; self.layer.borderWidth = width; self.layer.borderColor = [UIColor lightGrayColor].CGColor; &#125; return self;&#125;- (void)setFrame:(CGRect)frame&#123; frame.origin.y -= 0.5;//整体向上 移动0.5 frame.size.height += 0.5;//间隔为0.5 [super setFrame:frame];&#125;/** * 添加页面 */-(void)addSubview&#123; [self.contentView addSubview:self.titleLabel]; [self.contentView addSubview:self.textField];&#125;/** * 页面自动适配 */-(void) autoLayout&#123; [self.titleLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.offset(12.5); make.centerY.equalTo(self.contentView.mas_centerY); make.width.equalTo(@100); make.trailing.equalTo(self.textField.mas_leading).offset(-10); &#125;]; [self.textField mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.equalTo(self.contentView.mas_centerY); make.trailing.offset(-10); make.leading.equalTo(self.titleLabel.mas_trailing).offset(10); make.top.offset(10); make.bottom.offset(-10); &#125;];&#125;- (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self name:UITextFieldTextDidChangeNotification object:nil];&#125;-(void)textFieldChanging:(id)sender&#123; if (_block) &#123; _block(self.textField.text); &#125;&#125;-(void)setCellInfo:(NSString*)title withInputDesc:(NSString*)desc withKeybordType:(NSInteger)type withText:(NSString *)text WithReturnBlock:(void (^)(NSString *))textFieldBlock&#123; if (type==1) &#123; self.textField.keyboardType = UIKeyboardTypeNumberPad; &#125; _textField.text =text; _textField.clearButtonMode = UITextFieldViewModeWhileEditing; _block = textFieldBlock; _titleLabel.text = title; _textField.placeholder = desc;&#125;- (void)setSelected:(BOOL)selected animated:(BOOL)animated &#123; [super setSelected:selected animated:animated]; // Configure the view for the selected state&#125;@end 3.创建一个Info对象模型，存入所填写的内容123456789101112#import &lt;Foundation/Foundation.h&gt;@interface Info : NSObject@property (nonatomic,copy) NSString *name1;@property (nonatomic,copy) NSString *name2;@property (nonatomic,copy) NSString *name3;@property (nonatomic,copy) NSString *name4;@property (nonatomic,copy) NSString *name5;@property (nonatomic,copy) NSString *name6;@property (nonatomic,copy) NSString *name7;@end 4.使用方法123456789101112131415161718192021222324252627282930313233343536373839404142-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; NSString *identifier = [NSString stringWithFormat:@&quot;InputStrTableViewCellIdentifier%ld&quot;,indexPath.row]; InputStrTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier]; if (!cell) &#123; cell =[[InputStrTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier]; Info *info = [[Info alloc] init]; if (indexPath.row==0) &#123; [cell setCellInfo:@&quot;配偶信息：&quot; withInputDesc:info.name1&gt;0?info.name1:@&quot;请输入配偶信息&quot; withKeybordType:0 withText:@&quot;&quot; WithReturnBlock:^(NSString *result) &#123; info.name1 =result; &#125;]; &#125;else if (indexPath.row==1)&#123; [cell setCellInfo:@&quot;身份证：&quot; withInputDesc:info.name2&gt;0?info.name2:@&quot;请输入身份证号码&quot; withKeybordType:1 withText:@&quot;&quot; WithReturnBlock:^(NSString *result) &#123; info.name2 =result; &#125;]; &#125;else if (indexPath.row==2)&#123; [cell setCellInfo:@&quot;单位名称：&quot; withInputDesc:info.name3&gt;0?info.name3:@&quot;请输入单位名称&quot; withKeybordType:0 withText:@&quot;&quot; WithReturnBlock:^(NSString *result) &#123; info.name3 =result; &#125;]; &#125;else if (indexPath.row==3)&#123; [cell setCellInfo:@&quot;所在部门：&quot; withInputDesc:info.name4&gt;0?info.name4:@&quot;请输入所在部门&quot; withKeybordType:0 withText:@&quot;&quot; WithReturnBlock:^(NSString *result) &#123; info.name4 =result; &#125;]; &#125;else if (indexPath.row==4)&#123; [cell setCellInfo:@&quot;月均工资收入：&quot; withInputDesc:info.name5&gt;0?info.name5:@&quot;请输入月均工资收入&quot; withKeybordType:1 withText:@&quot;&quot; WithReturnBlock:^(NSString *result) &#123; info.name5 =result; &#125;]; &#125;else if (indexPath.row==5)&#123; [cell setCellInfo:@&quot;办公室电话：&quot; withInputDesc:info.name6&gt;0?info.name6:@&quot;请输入办公室电话&quot; withKeybordType:1 withText:@&quot;&quot; WithReturnBlock:^(NSString *result) &#123; info.name6 =result; &#125;]; &#125;else&#123; [cell setCellInfo:@&quot;移动电话：&quot; withInputDesc:info.name7&gt;0?info.name1:@&quot;请输入移动电话&quot; withKeybordType:1 withText:@&quot;&quot; WithReturnBlock:^(NSString *result) &#123; info.name7 =result; &#125;]; &#125; &#125; return cell;&#125; 注：只是粗糙的实现了功能，还有部分可优化的，代码已上传Github,喜欢的欢迎star一下，以资鼓励，嘿嘿， git地址 。]]></content>
      <tags>
        <tag>UITableView</tag>
        <tag>Cocoapods</tag>
        <tag>cell</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xxx.app文件已损坏，打不开，解决方案]]></title>
    <url>%2F14523.html</url>
    <content type="text"><![CDATA[现在很多软件是收费的，对于像我等穷屌丝来说，自然是想去找个破解的软件来替代，这个时候遇到xxx.app文件已损坏，打不开的情况，要怎么办呢，别急，以下操作就可以完美解决你的问题。 在Mac OS 更新到10.12之后，苹果爸爸对软件安全更加注重，在10.12之后你将看不到任何来源这个选项了 那么，我们在Mac OS 10.12之后要怎么才能显示这个任何来源的选项呢，其实很简单，你只需要在终端里输入sudo spctl --master-disable 这个时候会提示你输入电脑密码，（你输入的会不显示出来）输入密码后点击回车键，这个时候就打开了 这个时候，点击左下角的🔐,会让你输入电脑密码之后就可以选择任何来源了 点击允许任何来源这个时候你就可以打开之前提示文件损坏的软件了。]]></content>
  </entry>
</search>
