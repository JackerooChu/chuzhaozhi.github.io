<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS程序异常Crash友好化处理]]></title>
    <url>%2FiOS%E7%A8%8B%E5%BA%8F%E5%BC%82%E5%B8%B8Crash%E5%8F%8B%E5%A5%BD%E5%8C%96%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前两天接到个面试，面试官问到上线的app怎么避免闪退，首先想到的就是在编码的时候进行各种容错，但貌似并不是面试官想要的答案，所以表现的很糟糕。今天有时间就来整理一下，希望有所帮助。实现效果如图： 效果实现： 用法：1.将截图的中12.在```AppDelegate.m```中找到以下方法并如下添加代码： (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions { // Override point for customization after application launch. [UncaughtExceptionHandler installUncaughtExceptionHandler:YES showAlert:YES]; return YES;} 123以上代码就可以实现稍微友好一点的crash拦截处理。## 代码解释：```UncaughtExceptionHandler.h```主要代码： #import &lt;Foundation/Foundation.h&gt; #import &lt;UIKit/UIKit.h&gt; @interface UncaughtExceptionHandler : NSObject /*! 异常的处理方法* @param install 是否开启捕获异常 @param showAlert 是否在发生异常时弹出alertView*/ (void)installUncaughtExceptionHandler:(BOOL)install showAlert:(BOOL)showAlert;@end12```UncaughtExceptionHandler.m```文件主要的代码如下：#### 1.发送异常信号 /* 异常的处理方法* @param install 是否开启捕获异常 @param showAlert 是否在发生异常时弹出alertView*/ (void)installUncaughtExceptionHandler:(BOOL)install showAlert:(BOOL)showAlert { if (install &amp;&amp; showAlert) { [[self alloc] alertView:showAlert]; } NSSetUncaughtExceptionHandler(install ? HandleException : NULL);signal(SIGABRT, install ? SignalHandler : SIG_DFL);signal(SIGILL, install ? SignalHandler : SIG_DFL);signal(SIGSEGV, install ? SignalHandler : SIG_DFL);signal(SIGFPE, install ? SignalHandler : SIG_DFL);signal(SIGBUS, install ? SignalHandler : SIG_DFL);signal(SIGPIPE, install ? SignalHandler : SIG_DFL);} 1234 产生上述的signal的时候就会调用我们定义的```SignalHandler```来处理异常。 &gt; ps: NSSetUncaughtExceptionHandler就是iOS SDK中提供的一个现成的函数,用来捕获异常的方法，使用方便。但它不能捕获抛出的signal，所以定义了SignalHandler方法。#### 2.处理异常 void HandleException(NSException *exception) { int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount); // 如果太多不用处理 if (exceptionCount &gt; UncaughtExceptionMaximum) { return; } //获取调用堆栈 NSArray *callStack = [exception callStackSymbols]; NSMutableDictionary *userInfo = [NSMutableDictionary dictionaryWithDictionary:[exception userInfo]]; [userInfo setObject:callStack forKey:UncaughtExceptionHandlerAddressesKey]; //在主线程中，执行制定的方法, withObject是执行方法传入的参数 [[[UncaughtExceptionHandler alloc] init] performSelectorOnMainThread:@selector(handleException:) withObject: [NSException exceptionWithName:[exception name] reason:[exception reason] userInfo:userInfo] waitUntilDone:YES]; } 12该方法就是对应```NSSetUncaughtExceptionHandler```的处理，只要方法关联到这个函数，那么发生相应错误时会自动调用该函数，调用时会传入```exception```参数。获取异常后会将捕获的异常传入最终调用处理的```handleException```函数。#### 3.无法捕获的signal处理 //处理signal报错void SignalHandler(int signal) { int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount); // 如果太多不用处理 if (exceptionCount &gt; UncaughtExceptionMaximum) { return; } NSString* description = nil; switch (signal) { case SIGABRT: description = [NSString stringWithFormat:@&quot;Signal SIGABRT was raised!\n&quot;]; break; case SIGILL: description = [NSString stringWithFormat:@&quot;Signal SIGILL was raised!\n&quot;]; break; case SIGSEGV: description = [NSString stringWithFormat:@&quot;Signal SIGSEGV was raised!\n&quot;]; break; case SIGFPE: description = [NSString stringWithFormat:@&quot;Signal SIGFPE was raised!\n&quot;]; break; case SIGBUS: description = [NSString stringWithFormat:@&quot;Signal SIGBUS was raised!\n&quot;]; break; case SIGPIPE: description = [NSString stringWithFormat:@&quot;Signal SIGPIPE was raised!\n&quot;]; break; default: description = [NSString stringWithFormat:@&quot;Signal %d was raised!&quot;,signal]; } NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; NSArray *callStack = [UncaughtExceptionHandler backtrace]; [userInfo setObject:callStack forKey:UncaughtExceptionHandlerAddressesKey]; [userInfo setObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey]; //在主线程中，执行指定的方法, withObject是执行方法传入的参数 [[[UncaughtExceptionHandler alloc] init] performSelectorOnMainThread:@selector(handleException:) withObject: [NSException exceptionWithName:UncaughtExceptionHandlerSignalExceptionName reason: description userInfo: userInfo] waitUntilDone:YES]; } 12以上方法是对于捕获不到的signal信号进行处理，列出常见的异常类型。#### 4.堆栈调用 //获取调用堆栈 (NSArray *)backtrace { //指针列表 void callstack[128]; //backtrace用来获取当前线程的调用堆栈，获取的信息存放在这里的callstack中 //128用来指定当前的buffer中可以保存多少个void元素 //返回值是实际获取的指针个数 int frames = backtrace(callstack, 128); //backtrace_symbols将从backtrace函数获取的信息转化为一个字符串数组 //返回一个指向字符串数组的指针 //每个字符串包含了一个相对于callstack中对应元素的可打印信息，包括函数名、偏移地址、实际返回地址 char **strs = backtrace_symbols(callstack, frames); int i; NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames]; for (i = 0; i &lt; frames; i++) { [backtrace addObject:[NSString stringWithUTF8String:strs[i]]]; } free(strs); return backtrace;} 12&gt; backtrace是Linux下用来追踪函数调用堆栈以及定位段错误的函数。#### 5.使用UIAlerView进行友好化提示 (void)handleException:(NSException *)exception { [self validateAndSaveCriticalApplicationData:exception]; if (!showAlertView) { return; } #pragma clang diagnostic push #pragma clang diagnostic ignored “-Wdeprecated-declarations” UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@”出错啦” message:[NSString stringWithFormat:@”你可以尝试继续操作，但是应用可能无法正常运行.\n”] delegate:self cancelButtonTitle:@”退出” otherButtonTitles:@”继续”, nil]; [alert show]; #pragma clang diagnostic pop CFRunLoopRef runLoop = CFRunLoopGetCurrent(); CFArrayRef allModes = CFRunLoopCopyAllModes(runLoop); while (!self.dismissed) { //点击继续 for (NSString *mode in (__bridge NSArray *)allModes) { //快速切换Mode CFRunLoopRunInMode((CFStringRef)mode, 0.001, false); } } //点击退出 CFRelease(allModes); NSSetUncaughtExceptionHandler(NULL); signal(SIGABRT, SIG_DFL); signal(SIGILL, SIG_DFL); signal(SIGSEGV, SIG_DFL); signal(SIGFPE, SIG_DFL); signal(SIGBUS, SIG_DFL); signal(SIGPIPE, SIG_DFL); if ([[exception name] isEqual:UncaughtExceptionHandlerSignalExceptionName]) { kill(getpid(), [[[exception userInfo] objectForKey:UncaughtExceptionHandlerSignalKey] intValue]); } else { [exception raise]; } }` 在这里你可以做自己的crash收集操作，例如上传服务器等。 最后，我想说对网上给的这个拦截处理个人理解的不是很透彻，借鉴了多位大牛的技术分享，如果有新的解决方案，麻烦评论告诉我，大家一起共同进步。本文已同步至本人博客 代码传送门更多文章]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>Carsh</tag>
        <tag>崩溃拦截</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中优雅的使用iconfont]]></title>
    <url>%2FiOS%E4%B8%AD%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8iconfont.html</url>
    <content type="text"><![CDATA[1.什么是iconfont&ensp;&ensp;&ensp;&ensp;iconFont拆开来看，就是 Icon + Font，这样估计大家应该都能理解是什么，那两者结合是什么呢？没错！就是 IconFont ！让开发者像使用字体一样使用图标。如果自己不会做的话，可以直接去阿里的iconfont图标库下载自己需要的图标。 2.为什么要使用iconfont&ensp;&ensp;&ensp;&ensp;在开发项目时，不可避免的会用到各种图标，为了适配不同的设备，通常需要@2x和@3x两套图，例如说我们tabBar上使用的图标。有些app有换肤的需要，还需要多套不同的图来进行匹配不同的主题。如果使用切图，这对于设计和开发来说无疑是增加了工作量，而且ipa的体积也会增大。 使用iconfont的好处: 减小ipa包的大小 图标保真缩放，多设备适配一套图解决问题 适应换肤要求，使用方便。 3.怎么用iconfont1. 首先去iconfont图标库下载自己需要的图标。 如图我们可以选择自己需要的icon加入到购物车，然后加入项目里，当然你也可以直接在购物车直接下载，但是这样只是没有修改icon为自己想要的样式，加入项目中，你可以自己任意修改icon为自己想要的样式。 注意：这里是下载代码，这样我们就可以在项目中直接使用 2.将下载下来的icon资源添加到自己的项目中。我们所需要的就是这个iconfont.ttf，对于这个ttf文件，我想我们并不陌生吧。新建项目，将这个ttf文件拖入自己的项目里。 注意：勾选如图选项 接下来配置项目加载这个文件 检查文件是否在项目中，不然会崩溃 在plist文件中加入字体接下来我们借助淘点点科技写的一个关于iconfont封装，方便我们使用iconfont。iconfont的封装包括 TBCityIconInfo.h的实现 12345678910111213#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@interface TBCityIconInfo : NSObject@property (nonatomic, strong) NSString *text;@property (nonatomic, assign) NSInteger size;@property (nonatomic, strong) UIColor *color;- (instancetype)initWithText:(NSString *)text size:(NSInteger)size color:(UIColor *)color;+ (instancetype)iconInfoWithText:(NSString *)text size:(NSInteger)size color:(UIColor *)color;@end TBCityIconInfo.m的实现 123456789101112131415161718#import &quot;TBCityIconInfo.h&quot;@implementation TBCityIconInfo- (instancetype)initWithText:(NSString *)text size:(NSInteger)size color:(UIColor *)color &#123;if (self = [super init]) &#123;self.text = text;self.size = size;self.color = color;&#125;return self;&#125;+ (instancetype)iconInfoWithText:(NSString *)text size:(NSInteger)size color:(UIColor *)color &#123;return [[TBCityIconInfo alloc] initWithText:text size:size color:color];&#125;@end TBCityIconFont.h的实现 123456789#import &quot;UIImage+TBCityIconFont.h&quot;#import &quot;TBCityIconInfo.h&quot;#define TBCityIconInfoMake(text, imageSize, imageColor) [TBCityIconInfo iconInfoWithText:text size:imageSize color:imageColor]@interface TBCityIconFont : NSObject+ (UIFont *)fontWithSize: (CGFloat)size;+ (void)setFontName:(NSString *)fontName; TBCityIconFont.m的实现 1234567891011121314151617181920212223242526272829303132333435363738#import &quot;TBCityIconFont.h&quot;#import &lt;CoreText/CoreText.h&gt;@implementation TBCityIconFontstatic NSString *_fontName;+ (void)registerFontWithURL:(NSURL *)url &#123;NSAssert([[NSFileManager defaultManager] fileExistsAtPath:[url path]], @&quot;Font file doesn&apos;t exist&quot;);CGDataProviderRef fontDataProvider = CGDataProviderCreateWithURL((__bridge CFURLRef)url);CGFontRef newFont = CGFontCreateWithDataProvider(fontDataProvider);CGDataProviderRelease(fontDataProvider);CTFontManagerRegisterGraphicsFont(newFont, nil);CGFontRelease(newFont);&#125;+ (UIFont *)fontWithSize:(CGFloat)size &#123;UIFont *font = [UIFont fontWithName:[self fontName] size:size];if (font == nil) &#123;NSURL *fontFileUrl = [[NSBundle mainBundle] URLForResource:[self fontName] withExtension:@&quot;ttf&quot;];[self registerFontWithURL: fontFileUrl];font = [UIFont fontWithName:[self fontName] size:size];NSAssert(font, @&quot;UIFont object should not be nil, check if the font file is added to the application bundle and you&apos;re using the correct font name.&quot;);&#125;return font;&#125;+ (void)setFontName:(NSString *)fontName &#123;_fontName = fontName;&#125;+ (NSString *)fontName &#123;return _fontName ? : @&quot;iconfont&quot;;&#125;@end UIImage+TBCityIconFont.h的实现 12345678#import &lt;UIKit/UIKit.h&gt;#import &quot;TBCityIconInfo.h&quot;@interface UIImage (TBCityIconFont)+ (UIImage *)iconWithInfo:(TBCityIconInfo *)info;@end UIImage+TBCityIconFont.m的实现 123456789101112131415161718192021222324252627282930313233343536#import &quot;UIImage+TBCityIconFont.h&quot;#import &quot;TBCityIconFont.h&quot;#import &lt;CoreText/CoreText.h&gt;@implementation UIImage (TBCityIconFont)+ (UIImage *)iconWithInfo:(TBCityIconInfo *)info &#123;CGFloat size = info.size;CGFloat scale = [UIScreen mainScreen].scale;CGFloat realSize = size * scale;UIFont *font = [TBCityIconFont fontWithSize:realSize];UIGraphicsBeginImageContext(CGSizeMake(realSize, realSize));CGContextRef context = UIGraphicsGetCurrentContext();if ([info.text respondsToSelector:@selector(drawAtPoint:withAttributes:)]) &#123;/*** 如果这里抛出异常，请打开断点列表，右击All Exceptions -&gt; Edit Breakpoint -&gt; All修改为Objective-C* See: http://stackoverflow.com/questions/1163981/how-to-add-a-breakpoint-to-objc-exception-throw/14767076#14767076*/[info.text drawAtPoint:CGPointZero withAttributes:@&#123;NSFontAttributeName:font, NSForegroundColorAttributeName: info.color&#125;];&#125; else &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;CGContextSetFillColorWithColor(context, info.color.CGColor);[info.text drawAtPoint:CGPointMake(0, 0) withFont:font];#pragma clang pop&#125;UIImage *image = [UIImage imageWithCGImage:UIGraphicsGetImageFromCurrentImageContext().CGImage scale:scale orientation:UIImageOrientationUp];UIGraphicsEndImageContext();return image;&#125;@end 3.具体使用方法1.在AppDelegate.m中，初始化iconfont123456789101112131415161718#import &quot;AppDelegate.h&quot;#import &quot;TBCityIconFont.h&quot;#import &quot;ViewController.h&quot;@interface AppDelegate ()@end@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;// Override point for customization after application launch.[TBCityIconFont setFontName:@&quot;iconfont&quot;];UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:[ViewController new]];self.window.rootViewController = nav;[self.window makeKeyAndVisible];return YES;&#125; 在ViewController.m中实现12345678910111213141516171819202122232425262728293031323334353637383940414243#import &quot;ViewController.h&quot;#import &quot;TBCityIconFont.h&quot;#import &quot;UIImage+TBCityIconFont.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];self.view.backgroundColor = [UIColor whiteColor];UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 30, 30)];[self.view addSubview:imageView];//图标编码是&amp;#xe600，需要转成\U0000e600imageView.image = [UIImage iconWithInfo:TBCityIconInfoMake(@&quot;\U0000e600&quot;, 30, [UIColor redColor])];// buttonUIButton *button = [UIButton buttonWithType:UIButtonTypeSystem];button.frame = CGRectMake(100, 150, 40, 40);[self.view addSubview:button];[button setImage:[UIImage iconWithInfo:TBCityIconInfoMake(@&quot;\U0000e614&quot;, 40, [UIColor redColor])] forState:UIControlStateNormal];// label,label可以将文字与图标结合一起，直接用label的text属性将图标显示出来UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(50, 200, 280, 40)];[self.view addSubview:label];label.font = [UIFont fontWithName:@&quot;iconfont&quot; size:15];//设置label的字体label.text = @&quot;在lable上显示 \U0000e658&quot;;// Do any additional setup after loading the view, typically from a nib.&#125;- (void)didReceiveMemoryWarning &#123;[super didReceiveMemoryWarning];// Dispose of any resources that can be recreated.&#125;@end 结果如下图所示： 注意： 所用到的unicode编码需要自己手动将&amp;#xXXXX格式转换成\UXXXXXXXX格式，例如//图标编码是&amp;#xe600，需要转成\U0000e600 所有需要的unicode编码都可以在下载的iconfont文件夹中的.html文件打开查看 本文demo,欢迎批评指正，留下你的star哦。]]></content>
      <tags>
        <tag>ios</tag>
        <tag>iconfont</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles抓包+Postman模拟请求]]></title>
    <url>%2FCharles%E6%8A%93%E5%8C%85%2BPostman%E6%A8%A1%E6%8B%9F%E8%AF%B7%E6%B1%82.html</url>
    <content type="text"><![CDATA[一、工具介绍1. Charles今天来介绍一下Mac上抓包工具Charles(又称为青花瓷)，官网可以下载，但是需要破解之后才能永久使用，当然，可以有30天试用期，具体的使用方法在此就不进行一一介绍了，如有需要再补上。（ps:破解版下载地址密码:meuk)。 2.PostmanPostman是一种网页调试与发送网页http请求的chrome插件。我们可以用来很方便的模拟get或者post或者其他方式的请求来调试接口。点击下载 二、开始抓取网络接口以及模拟请求第一步、打开Charles,在浏览器中输入需要请求的地址，我这里访问的是一个投票的接口显示信息如下：cookie信息：参数信息： 第二步、在第一步获取了请求的url、cookie、参数等请求需要的之后我们就可以打开Postman来进行模拟请求了。配置信息如下：body参数：第三步、发送请求，看到后台返回的信息到这里这个请求接口的操作就模拟成功了，既然参数和地址都有了，这个时候就是你想做什么就做什么的时候了，你懂得😆。 这是根据postman请求结果，自己随便写了个手机端来进行请求的，有兴趣的可以一起研究，欢迎骚扰。]]></content>
      <categories>
        <category>IT技能</category>
      </categories>
      <tags>
        <tag>抓包</tag>
        <tag>Charles</tag>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reveal---iOS项目UI调试工具使用教程]]></title>
    <url>%2FReveal---iOS%E9%A1%B9%E7%9B%AEUI%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[一、Reveal介绍 Reveal是Mac os平台上的一款开发者调试IOS应用的Mac[开发软件]reveal Mac版它能够在运行时调试和修改iOS应用程序。Reveal能连接到应用程序，并允许开发者编辑各种用户界面参数，这反过来会立即反应在程序的UI上。Reveal 在 官网售价119美元，约合人民币1280元]，（文末会给出破解版的下载地址，当然，要支持正版哟^_^）。 二、Reveal集成使用1、下载安装Reveal，直接安装。如果提示xxx.app文件损坏打不开，请参考我的另一篇文章解决，这里了就不多说了。 2、找到你刚才安装的软件,打开主界面显示如下图 3、在你的项目中集成（1）创建一个名为RevealTestDemo的项目,导入CocoPods,打开Podfile文件输入12// :configurations =&gt; [&apos;Debug&apos;] 只是在xcode debug 时才会加入；pod &apos;Reveal-SDK&apos;, :git =&gt; &apos;https://git.coding.net/kakukeme/Reveal-SDK.git&apos;, :configurations =&gt; [&apos;Debug&apos;] （2）、Xcode打开项目，并运行 在界面上添加一个背景颜色为红色的label,这个时候打开Reveal,你就能看到点击进入就能看到 4、功能分析窗口介绍点击一个控件之后进入这个子控件的详细信息 在属性窗口里面我们能很清晰的看见这个控件的相关信息，包括Frame等，同时你还可以直接在属性面板进行修改控件的信息 修改前修改后 是不是很方便，修改字体、颜色、大小、对齐方式等都可以在属性面板进行操作，很直观的看到修改后的效果，不幸的是，你项目中的代码还需要自己去修改（据说后期版本会有对这一方面的修改，期待ing）。本文Demo地址,Reveal下载地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[UITableViewCell上的输入框，输入不同内容]]></title>
    <url>%2FUITableViewCell%E4%B8%8A%E7%9A%84%E8%BE%93%E5%85%A5%E6%A1%86%EF%BC%8C%E8%BE%93%E5%85%A5%E4%B8%8D%E5%90%8C%E5%86%85%E5%AE%B9.html</url>
    <content type="text"><![CDATA[一、实现效果本文介绍怎么在UITableViewCell中添加输入框，对于不同的row的输入框输入的文本进行获取以至于打到一个表单填写的效果。 二、项目结构 三、代码部分1. 项目使用Cocoapods管理 在控制台对创建的项目进行创建pods，创建Podfile文件，使用命令vi Podfile进入到Podfile文件里面，按下键盘i进入编辑状态 输入我们需要使用的第三方库，此项目中使用了Masonry来进行适配 1234platform :ios, &apos;8.0&apos;target &apos;InputInfoDemo&apos; dopod &apos;Masonry&apos;end 在写好上一步的代码后，按ESC,然后输入:wq回车退出编辑状态 使用命令pod instal进行第三方库安装，当出现以下内容的时候表示你已经装好Masonry了######2.创建需要显示的自定义UITableViewCell**.h文件**1234567891011121314151617181920212223//// InputStrTableViewCell.h//// Created by Jackeroo on 2017/5/27.// Copyright © 2017年 Jackeroo. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;@interface InputStrTableViewCell : UITableViewCell@property (nonatomic, strong) UITextField *textField;/** 设置cell信息 @param title cell左侧标题 @param desc 占位文字信息 @param type 键盘类型 0、表示正常键盘 1、表示数字键盘 @param text 填充文字 @param textFieldBlock 输入内容回调 */-(void)setCellInfo:(NSString*)title withInputDesc:(NSString*)desc withKeybordType:(NSInteger )type withText:(NSString *)text WithReturnBlock:(void (^)(NSString *result))textFieldBlock;@end **.m文件**123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//// InputStrTableViewCell.m//// Created by Jackeroo on 2017/5/27.// Copyright © 2017年 Jackeroo. All rights reserved.//// 颜色#define RGBA(r,g,b,a) [UIColor colorWithRed:(r)/255.0f green:(g)/255.0f blue:(b)/255.0f alpha:a]#import &quot;InputStrTableViewCell.h&quot;#import &quot;Masonry.h&quot;#import &quot;View+MASShorthandAdditions.h&quot;@interface InputStrTableViewCell()&lt;UITextFieldDelegate&gt;// 标题Label@property (nonatomic, strong) UILabel *titleLabel;@end@implementation InputStrTableViewCell&#123;// 输入回调 void (^_block)(NSString *inputResult);&#125;- (void)awakeFromNib &#123; [super awakeFromNib]; // Initialization code&#125;// 初始化- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123; self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if (self) &#123; self.backgroundColor =RGBA(242, 242, 242, 1); self.selectionStyle = UITableViewCellSelectionStyleNone; self.titleLabel = [[UILabel alloc] init]; self.titleLabel.font =[UIFont systemFontOfSize:14]; self.titleLabel.textColor = [UIColor blackColor]; self.textField = [[UITextField alloc] init]; self.textField.font = [UIFont systemFontOfSize:12]; self.textField.textColor = [UIColor grayColor]; self.textField.textAlignment = NSTextAlignmentRight; self.textField.delegate = self; self.textField.backgroundColor = [UIColor whiteColor]; self.textField.clearButtonMode = UITextFieldViewModeAlways; // 添加输入完成会回调通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFieldChanging:) name:UITextFieldTextDidChangeNotification object:self.textField]; [self addSubview]; [self autoLayout]; CGFloat scale = [[UIScreen mainScreen] scale]; CGFloat width = scale &gt; 0.0 ? 1.0 / scale : 1.0; self.layer.borderWidth = width; self.layer.borderColor = [UIColor lightGrayColor].CGColor; &#125; return self;&#125;- (void)setFrame:(CGRect)frame&#123; frame.origin.y -= 0.5;//整体向上 移动0.5 frame.size.height += 0.5;//间隔为0.5 [super setFrame:frame];&#125;/** * 添加页面 */-(void)addSubview&#123; [self.contentView addSubview:self.titleLabel]; [self.contentView addSubview:self.textField];&#125;/** * 页面自动适配 */-(void) autoLayout&#123; [self.titleLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.offset(12.5); make.centerY.equalTo(self.contentView.mas_centerY); make.width.equalTo(@100); make.trailing.equalTo(self.textField.mas_leading).offset(-10); &#125;]; [self.textField mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.equalTo(self.contentView.mas_centerY); make.trailing.offset(-10); make.leading.equalTo(self.titleLabel.mas_trailing).offset(10); make.top.offset(10); make.bottom.offset(-10); &#125;];&#125;- (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self name:UITextFieldTextDidChangeNotification object:nil];&#125;-(void)textFieldChanging:(id)sender&#123; if (_block) &#123; _block(self.textField.text); &#125;&#125;-(void)setCellInfo:(NSString*)title withInputDesc:(NSString*)desc withKeybordType:(NSInteger)type withText:(NSString *)text WithReturnBlock:(void (^)(NSString *))textFieldBlock&#123; if (type==1) &#123; self.textField.keyboardType = UIKeyboardTypeNumberPad; &#125; _textField.text =text; _textField.clearButtonMode = UITextFieldViewModeWhileEditing; _block = textFieldBlock; _titleLabel.text = title; _textField.placeholder = desc;&#125;- (void)setSelected:(BOOL)selected animated:(BOOL)animated &#123; [super setSelected:selected animated:animated]; // Configure the view for the selected state&#125;@end 3.创建一个Info对象模型，存入所填写的内容123456789101112#import &lt;Foundation/Foundation.h&gt;@interface Info : NSObject@property (nonatomic,copy) NSString *name1;@property (nonatomic,copy) NSString *name2;@property (nonatomic,copy) NSString *name3;@property (nonatomic,copy) NSString *name4;@property (nonatomic,copy) NSString *name5;@property (nonatomic,copy) NSString *name6;@property (nonatomic,copy) NSString *name7;@end 4.使用方法123456789101112131415161718192021222324252627282930313233343536373839404142-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; NSString *identifier = [NSString stringWithFormat:@&quot;InputStrTableViewCellIdentifier%ld&quot;,indexPath.row]; InputStrTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier]; if (!cell) &#123; cell =[[InputStrTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier]; Info *info = [[Info alloc] init]; if (indexPath.row==0) &#123; [cell setCellInfo:@&quot;配偶信息：&quot; withInputDesc:info.name1&gt;0?info.name1:@&quot;请输入配偶信息&quot; withKeybordType:0 withText:@&quot;&quot; WithReturnBlock:^(NSString *result) &#123; info.name1 =result; &#125;]; &#125;else if (indexPath.row==1)&#123; [cell setCellInfo:@&quot;身份证：&quot; withInputDesc:info.name2&gt;0?info.name2:@&quot;请输入身份证号码&quot; withKeybordType:1 withText:@&quot;&quot; WithReturnBlock:^(NSString *result) &#123; info.name2 =result; &#125;]; &#125;else if (indexPath.row==2)&#123; [cell setCellInfo:@&quot;单位名称：&quot; withInputDesc:info.name3&gt;0?info.name3:@&quot;请输入单位名称&quot; withKeybordType:0 withText:@&quot;&quot; WithReturnBlock:^(NSString *result) &#123; info.name3 =result; &#125;]; &#125;else if (indexPath.row==3)&#123; [cell setCellInfo:@&quot;所在部门：&quot; withInputDesc:info.name4&gt;0?info.name4:@&quot;请输入所在部门&quot; withKeybordType:0 withText:@&quot;&quot; WithReturnBlock:^(NSString *result) &#123; info.name4 =result; &#125;]; &#125;else if (indexPath.row==4)&#123; [cell setCellInfo:@&quot;月均工资收入：&quot; withInputDesc:info.name5&gt;0?info.name5:@&quot;请输入月均工资收入&quot; withKeybordType:1 withText:@&quot;&quot; WithReturnBlock:^(NSString *result) &#123; info.name5 =result; &#125;]; &#125;else if (indexPath.row==5)&#123; [cell setCellInfo:@&quot;办公室电话：&quot; withInputDesc:info.name6&gt;0?info.name6:@&quot;请输入办公室电话&quot; withKeybordType:1 withText:@&quot;&quot; WithReturnBlock:^(NSString *result) &#123; info.name6 =result; &#125;]; &#125;else&#123; [cell setCellInfo:@&quot;移动电话：&quot; withInputDesc:info.name7&gt;0?info.name1:@&quot;请输入移动电话&quot; withKeybordType:1 withText:@&quot;&quot; WithReturnBlock:^(NSString *result) &#123; info.name7 =result; &#125;]; &#125; &#125; return cell;&#125; 注：只是粗糙的实现了功能，还有部分可优化的，代码已上传Github,喜欢的欢迎star一下，以资鼓励，嘿嘿， git地址 。]]></content>
      <tags>
        <tag>UITableView</tag>
        <tag>Cocoapods</tag>
        <tag>cell</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableViewCell高度自适应--Xib和Masonry布局]]></title>
    <url>%2FUITableViewCell%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94--Xib%E5%92%8CMasonry%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS微信支付以及工具类]]></title>
    <url>%2FWeiXinPayService.html</url>
    <content type="text"><![CDATA[在刚刚结束的一个项目中用到了微信支付，从接入微信支付到工具类的封装，在本文中做个积累，方便日后使用。 1.开始接入微信支付的准备工作 首先你需要去微信开放平台注册账号,在这里要吐槽一下，不知道这个微信平台的账号密码验证机制，忘了以前的密码，重新登录，各种找回密码都不行，实在没辙，去注册个Gmail😑，登录成功后，可以看到如下界面。 点击右上角的创建移动应用，一步一步填写必要填入的信息，在这里就不做多余的赘述了。需要注意的是这里填入的Bundle ID需要和项目的一一对应接下来就等一个星期左右，等待微信审核通过你就可以将微信支付SDK集成到项目中，详情可以看官方给出的文档.pod 集成方法1pod &apos;WechatOpenSDK&apos; 在Xcode中，选择你的工程设置项，选中“TARGETS”一栏，在“info”标签栏的“URL type“添加“URL scheme”为你所注册的应用程序id（如下图所示）。 完成之后可以获取到appid(微信开放平台为应用生成的唯一识别码)、商户id、商户secretKey。对于app端来说只用到appid，商户id最好通过接口从server获取，商户secretKey是用来签名的，一般只有server能用到。 2.支付流程 刚开始看这个流程图可能会觉得很复杂，所以总结了我们比较关系的流程是： app客户端向服务器发送支付请求 服务器在收到客户端请求之后向微信后台调用统一下单API,获得预付单信息 服务端生成带签名的客户端支付信息给app app客户端用户确认支付，app唤醒微信客户端进行支付 app获得支付结果后向服务端查询最终的结果并显示 app端的工作： 接入微信支付SDK 向服务器发送支付请求 支付信息唤醒微信app,然后进行支付 收到微信支付回调后向服务器确认支付结果 根据查询结果展示结果页面告知用户支付结果 服务器端的工作： 收到app客户端支付请求后向微信后台请求预支付订单 服务器端签名并返回信息给app客户端 接收微信后台返回的支付结果，用来app端查询 服务器端返回的字段说明： appId:返回的appid partnerId: 父级id prepayId: 支付id packages: 包名（微信默认的为“Sign=WXPay”） nonceStr: 生成的随机字符串 timesTamp: 时间戳 sign: 签名 3.iOS端使用在AppDelegate.m,导入微信SDK头文件WXApi.h123456789101112131415161718192021- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;[WXApi registerApp:@&quot;注册获得的appid&quot;];//注册appidreturn YES;&#125;//支持所有iOS系统回调- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123;// [self handleOpenURL:url];BOOL result = [[UMSocialManager defaultManager] handleOpenURL:url sourceApplication:sourceApplication annotation:annotation];if (!result) &#123;// 其他如支付等SDK的回调[self handleOpenURL:url];&#125;return YES;&#125;- (void)handleOpenURL:(NSURL*)url &#123;if ([url.host isEqualToString:@&quot;pay&quot;]) &#123; // -- 微信支付[WXApi handleOpenURL:url delegate:[WXPayService sharedInstance]];&#125;&#125; 此处的WXPayService就是自己单独抽出来写的一个类，遵循WXApiManagerDelegate协议 WXPayService.h12345678910111213#import &lt;Foundation/Foundation.h&gt;#import &quot;WXApi.h&quot;@interface WXPayService : NSObject &lt;WXApiDelegate&gt;///单例来接收微信请求的回调+ (instancetype)sharedInstance;// -- 根据接口返回的预支付信息,构造支付请求+ (PayReq *)getPayRequest:(NSDictionary *)prepayData;///处理非支付请求的回调- (void)onRespCallBack:(void(^)(BaseResp * resp))callback;///从服务器端获取到微信返回的支付请求用到的参数来发起支付请求- (void)startPayWithReq:(PayReq *)req callback:(void(^)(BaseResp * resp))callback; @end WXPayService.m1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#import &quot;WXPayService.h&quot;@interface WXPayService ()@property (nonatomic,copy) void(^RespCallBack)(BaseResp *);@endstatic WXPayService *sharedInstance;@implementation WXPayService+ (instancetype)allocWithZone:(struct _NSZone *)zone&#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;sharedInstance = [super allocWithZone:zone];&#125;);return sharedInstance;&#125;///单例来接收微信请求的回调+ (instancetype)sharedInstance &#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;sharedInstance = [[self alloc] init];&#125;);return sharedInstance;&#125;// -- 根据接口返回的预支付信息,构造支付请求+ (PayReq *)getPayRequest:(NSDictionary *)prepayData &#123;if (prepayData) &#123;// 此处Tools是自己的另一个工具类，用来判断字典的PayReq *req = [[PayReq alloc] init];if ([Tools dicContain:prepayData withKey:@&quot;partnerid&quot;]) &#123;req.partnerId = prepayData[@&quot;partnerid&quot;];&#125;if ([Tools dicContain:prepayData withKey:@&quot;prepayid&quot;]) &#123;req.prepayId = prepayData[@&quot;prepayid&quot;];&#125;if ([Tools dicContain:prepayData withKey:@&quot;noncestr&quot;]) &#123;req.nonceStr = prepayData[@&quot;noncestr&quot;];&#125;if ([Tools dicContain:prepayData withKey:@&quot;timestamp&quot;]) &#123;req.timeStamp = [prepayData[@&quot;timestamp&quot;] intValue];&#125;req.package =@&quot;Sign=WXPay&quot;;req.sign = @&quot;null&quot;;//日志输出NSLog(@&quot;appid=%@/npartid=%@/nprepayid=%@/nnoncestr=%@/ntimestamp=%ld/npackage=%@/nsign=%@&quot;,[prepayData objectForKey:@&quot;appid&quot;],req.partnerId,req.prepayId,req.nonceStr,(long)req.timeStamp,req.package,req.sign);return req;&#125;return nil;&#125;///处理非支付请求的回调- (void)onRespCallBack:(void(^)(BaseResp * resp))callback &#123;self.RespCallBack = callback;&#125;///从服务器端获取到微信返回的支付请求用到的参数来发起支付请求- (void)startPayWithReq:(PayReq *)req callback:(void(^)(BaseResp * resp))callback &#123;NSAssert(req !=nil , @&quot;未成功创建微信支付请求&quot;);self.RespCallBack = callback;if ([WXApi isWXAppInstalled]) &#123; // -- 判断是否安装微信应用//发起微信支付,设置参数[WXApi sendReq:req];&#125;else &#123;self.RespCallBack(nil);&#125;&#125;#pragma mark WXApiDelegate- (void)onResp:(BaseResp *)resp &#123;if ([resp isKindOfClass:[PayResp class]]) &#123; // -- 判断是否为支付的回调self.RespCallBack(resp);&#125;&#125;@end 在需要支付的ViewController中导入工具类WXPayService 4.注意点及问题注意点： 设置好scheme,否则应用无法跳转到微信客户端 支付签名时的key值全部是小写的 如果支付显示验证签名失败的时候，可以将packages设为默认值(Sign=WXPay)试试 问题： 系统版本大于等于iOS9的，调起微信客户端之后，可以直接点击状态栏左侧按钮返回，这时是不走回调方法的。 解决方案：在AppDelegate.m的applicationWillEnterForeground方法中，调用查询支付结果接口然后刷新当然页面。需要设置bool变量作为标志，否则每次应用进入前台都去查询，就不符合业务要求了。 进入微信支付页面之后，不做操作，切换到自己应用中，退出当前支付页面，然后再进入微信客户端点击支付或者取消，此时自己的应用会崩溃闪退 原因：退出页面后页面已经出栈被销毁，但wx回调时还是去调用其中的代理方法，就会出现野指针。解决方案：在页面的viewWillDisappear方法中加入1[WXPayService sharedManager].delegate = nil; 5.结束语微信支付签名建议和服务端协商做二次签名，以保证支付的安全性。ps: 如有不对的地方，欢迎批评指正，另外安利一下个人的博客]]></content>
  </entry>
  <entry>
    <title><![CDATA[Xcode9-Safe-Area-Layout-Guide-Before-iOS9-0报错解决]]></title>
    <url>%2FXcode9-Safe-Area-Layout-Guide-Before-iOS9-0%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3.html</url>
    <content type="text"><![CDATA[9月20日苹果爸爸推送了iOS11.0以及Xcode9,作为开发小白一枚，第一时间更新了Xcode9,去体验一下所谓的跨时代的iPhone X,像往常新建个新项目，结果一运行直接报错（弱弱的说一句，这个xcode9好像并没有那么友好~）然后一Google，苹果爸爸在苹果在iOS7中引入的Top Layout Guide和Bottom Layout Guide,这些布局指南在iOS 11中被弃用，取而代之的是Safe Area Layout Guide.针对新特性，解决方案如下第一步、在项目报错地方打开右边工具栏找到如图位置选中View Controller，去掉Use Safe Area Layout Guides 第二步、切换到Main.storyboard文件,重读第一步操作打开右边工具栏找到如图位置选中View Controller，去掉Use Safe Area Layout Guides 到这就解决了这个问题，当然iOS11和Xcode9还有其他新特性，一点点整理解决。]]></content>
      <categories>
        <category>Xcode</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
        <tag>自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xxx.app文件已损坏，打不开，解决方案]]></title>
    <url>%2Fxxx-app%E6%96%87%E4%BB%B6%E5%B7%B2%E6%8D%9F%E5%9D%8F%EF%BC%8C%E6%89%93%E4%B8%8D%E5%BC%80%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
    <content type="text"><![CDATA[现在很多软件是收费的，对于像我等穷屌丝来说，自然是想去找个破解的软件来替代，这个时候遇到xxx.app文件已损坏，打不开的情况，要怎么办呢，别急，以下操作就可以完美解决你的问题。 在Mac OS 更新到10.12之后，苹果爸爸对软件安全更加注重，在10.12之后你将看不到任何来源这个选项了 那么，我们在Mac OS 10.12之后要怎么才能显示这个任何来源的选项呢，其实很简单，你只需要在终端里输入sudo spctl --master-disable 这个时候会提示你输入电脑密码，（你输入的会不显示出来）输入密码后点击回车键，这个时候就打开了 这个时候，点击左下角的🔐,会让你输入电脑密码之后就可以选择任何来源了 点击允许任何来源这个时候你就可以打开之前提示文件损坏的软件了。]]></content>
  </entry>
</search>
